

üìÅ –ù–û–í–Ü –ú–û–î–£–õ–Ü –î–õ–Ø –ü–û–ö–†–ê–©–ï–ù–ò–• –§–£–ù–ö–¶–Ü–ô

```
core/
‚îú‚îÄ‚îÄ enhanced_monitoring.py          # –ü–æ–∫—Ä–∞—â–µ–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
‚îú‚îÄ‚îÄ forensic_snapshot.py            # –ú–µ–¥—ñ–∞-–∫—Ä–∏–º—ñ–Ω–∞–ª—ñ—Å—Ç–∏–∫–∞
‚îú‚îÄ‚îÄ ai_sentiment.py                 # AI –∞–Ω–∞–ª—ñ–∑ –Ω–∞—Å—Ç—Ä–æ—é
‚îú‚îÄ‚îÄ anti_ghost_recovery.py          # –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
‚îú‚îÄ‚îÄ xray_metadata.py                # X-Ray –º–µ—Ç–∞–¥–∞–Ω—ñ
‚îî‚îÄ‚îÄ memory_indexer.py               # –Ü–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ
```

üïµÔ∏è‚Äç‚ôÇÔ∏è 1. FORENSIC SNAPSHOT (–ú–ï–î–Ü–ê-–ö–†–ò–ú–Ü–ù–ê–õ–Ü–°–¢–ò–ö–ê)

core/forensic_snapshot.py

```python
"""
Forensic Snapshot - –ú–æ–¥—É–ª—å –º–µ–¥—ñ–∞-–∫—Ä–∏–º—ñ–Ω–∞–ª—ñ—Å—Ç–∏–∫–∏
–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å—Ç–≤–æ—Ä—é—î –¥–∑–µ—Ä–∫–∞–ª–æ –≤—Å—ñ—Ö –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—ñ–≤ –∑ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–º–∏ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏
"""

import asyncio
import hashlib
import json
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, BinaryIO
import aiofiles
from PIL import Image
import exifread
from dataclasses import dataclass, asdict

from core.security import SecurityMonitor
from services.encryption import EncryptionService
from utils.decorators import timing_decorator, circuit_breaker

@dataclass
class MediaForensicData:
    """–§–æ—Ä–µ–Ω–∑–∏—á–Ω—ñ –¥–∞–Ω—ñ –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—É"""
    file_id: str
    original_hash: str
    forensic_hash: str
    timestamp: datetime
    user_id: int
    chat_id: int
    message_id: int
    media_type: str  # photo, video, document, voice, video_note
    original_metadata: Dict
    extracted_metadata: Dict
    file_size: int
    file_path: str
    deleted: bool = False
    deletion_time: Optional[datetime] = None
    snapshot_path: str = ""

class ForensicSnapshot:
    """–°–∏—Å—Ç–µ–º–∞ —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–Ω—ñ–º–∫—É –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—ñ–≤"""
    
    def __init__(self, storage_path: str = "data/forensic_snapshots"):
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        
        self.encryption = EncryptionService()
        self.security_monitor = SecurityMonitor()
        self.media_registry: Dict[str, MediaForensicData] = {}
        
        # –ü—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω—ñ —Ñ–æ—Ä–º–∞—Ç–∏ —Ç–∞ —ó—Ö –∞–Ω–∞–ª—ñ–∑–∞—Ç–æ—Ä–∏
        self.metadata_extractors = {
            'image/jpeg': self._extract_image_metadata,
            'image/png': self._extract_image_metadata,
            'video/mp4': self._extract_video_metadata,
            'application/pdf': self._extract_pdf_metadata,
            'text/plain': self._extract_text_metadata,
        }
    
    @circuit_breaker(failure_threshold=3, reset_timeout=30)
    async def capture_media(self, file_data: bytes, file_info: Dict, 
                          context: Dict) -> MediaForensicData:
        """
        –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—É –∑ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è–º —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–Ω—ñ–º–∫—É
        
        Args:
            file_data: –ë–∞–π—Ç–æ–≤—ñ –¥–∞–Ω—ñ —Ñ–∞–π–ª—É
            file_info: –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ —Ñ–∞–π–ª
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        
        Returns:
            MediaForensicData –∑ —É—Å—ñ–º–∞ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏
        """
        
        # –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ö–µ—à—ñ–≤
        original_hash = hashlib.sha256(file_data).hexdigest()
        forensic_hash = hashlib.sha512(file_data).hexdigest()
        
        # –í–∏—Ç—è–≥–Ω–µ–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
        original_metadata = file_info.get('metadata', {})
        extracted_metadata = await self._extract_all_metadata(file_data, file_info)
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–Ω—ñ–º–∫—É
        snapshot_id = f"{forensic_hash}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        snapshot_path = self.storage_path / f"{snapshot_id}.forensic"
        
        # –®–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è —Ç–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
        encrypted_data = await self.encryption.encrypt_data(file_data)
        async with aiofiles.open(snapshot_path, 'wb') as f:
            await f.write(encrypted_data)
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞–ø–∏—Å—É
        forensic_data = MediaForensicData(
            file_id=file_info.get('file_id', ''),
            original_hash=original_hash,
            forensic_hash=forensic_hash,
            timestamp=datetime.now(),
            user_id=context.get('user_id', 0),
            chat_id=context.get('chat_id', 0),
            message_id=context.get('message_id', 0),
            media_type=file_info.get('mime_type', 'unknown').split('/')[0],
            original_metadata=original_metadata,
            extracted_metadata=extracted_metadata,
            file_size=len(file_data),
            file_path=str(snapshot_path),
            snapshot_path=str(snapshot_path)
        )
        
        # –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –≤ —Å–∏—Å—Ç–µ–º—ñ
        self.media_registry[forensic_hash] = forensic_data
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
        await self._save_metadata(forensic_data)
        
        # –õ–æ–≥—É–≤–∞–Ω–Ω—è –ø–æ–¥—ñ—ó –±–µ–∑–ø–µ–∫–∏
        await self.security_monitor.log_event(
            "MEDIA_CAPTURED",
            "INFO",
            "ForensicSnapshot",
            f"–ó–∞—Ö–æ–ø–ª–µ–Ω–æ –º–µ–¥—ñ–∞: {forensic_hash}",
            user_id=context.get('user_id')
        )
        
        return forensic_data
    
    async def _extract_all_metadata(self, file_data: bytes, file_info: Dict) -> Dict:
        """–í–∏—Ç—è–≥–Ω–µ–Ω–Ω—è –≤—Å—ñ—Ö –º–æ–∂–ª–∏–≤–∏—Ö –º–µ—Ç–∞–¥–∞–Ω–∏—Ö"""
        metadata = {
            "basic": {
                "size": len(file_data),
                "hash_sha256": hashlib.sha256(file_data).hexdigest(),
                "hash_md5": hashlib.md5(file_data).hexdigest(),
                "timestamp": datetime.now().isoformat()
            },
            "exif": {},
            "hidden": {},
            "forensic": {}
        }
        
        mime_type = file_info.get('mime_type', '')
        
        # –í–∏—Ç—è–≥–Ω–µ–Ω–Ω—è EXIF –¥–ª—è –∑–æ–±—Ä–∞–∂–µ–Ω—å
        if mime_type.startswith('image/'):
            metadata["exif"] = await self._extract_exif_metadata(file_data)
        
        # –í–∏—Ç—è–≥–Ω–µ–Ω–Ω—è –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—ó
        if 'location' in file_info:
            metadata["geolocation"] = file_info['location']
        
        # –ê–Ω–∞–ª—ñ–∑ –±—ñ–Ω–∞—Ä–Ω–∏—Ö –¥–∞–Ω–∏—Ö –Ω–∞ –ø—Ä–∏—Ö–æ–≤–∞–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
        metadata["hidden"] = await self._analyze_hidden_data(file_data)
        
        # –§–æ—Ä–µ–Ω–∑–∏—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
        metadata["forensic"] = {
            "entropy": self._calculate_entropy(file_data),
            "magic_bytes": file_data[:8].hex() if len(file_data) >= 8 else '',
            "file_signature": self._analyze_file_signature(file_data)
        }
        
        return metadata
    
    async def _extract_exif_metadata(self, file_data: bytes) -> Dict:
        """–í–∏—Ç—è–≥–Ω–µ–Ω–Ω—è EXIF –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –∑ –∑–æ–±—Ä–∞–∂–µ–Ω—å"""
        exif_data = {}
        
        try:
            # –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è exifread
            tags = exifread.process_file(file_data)
            for tag in tags.keys():
                if tag not in ('JPEGThumbnail', 'TIFFThumbnail', 'Filename', 'EXIF MakerNote'):
                    exif_data[str(tag)] = str(tags[tag])
        except Exception as e:
            exif_data["error"] = str(e)
        
        # –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –∞–Ω–∞–ª—ñ–∑ —á–µ—Ä–µ–∑ PIL
        try:
            from io import BytesIO
            img = Image.open(BytesIO(file_data))
            exif_data.update({
                "format": img.format,
                "mode": img.mode,
                "size": img.size,
                "info": dict(img.info) if hasattr(img, 'info') else {}
            })
        except Exception:
            pass
        
        return exif_data
    
    def _calculate_entropy(self, data: bytes) -> float:
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –µ–Ω—Ç—Ä–æ–ø—ñ—ó –¥–∞–Ω–∏—Ö (–≤–∏—è–≤–ª—è—î —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è/—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è)"""
        if not data:
            return 0.0
        
        entropy = 0.0
        for x in range(256):
            p_x = float(data.count(x)) / len(data)
            if p_x > 0:
                entropy += - p_x * math.log(p_x, 2)
        
        return entropy
    
    async def recover_deleted_media(self, forensic_hash: str) -> Optional[bytes]:
        """
        –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–æ–≥–æ –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—É
        
        Args:
            forensic_hash: –•–µ—à —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–Ω—ñ–º–∫—É
        
        Returns:
            –ë–∞–π—Ç–æ–≤—ñ –¥–∞–Ω—ñ —Ñ–∞–π–ª—É –∞–±–æ None
        """
        if forensic_hash not in self.media_registry:
            return None
        
        forensic_data = self.media_registry[forensic_hash]
        
        try:
            # –ß–∏—Ç–∞–Ω–Ω—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—Ö –¥–∞–Ω–∏—Ö
            async with aiofiles.open(forensic_data.file_path, 'rb') as f:
                encrypted_data = await f.read()
            
            # –î–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è
            decrypted_data = await self.encryption.decrypt_data(encrypted_data)
            
            # –ü–æ–∑–Ω–∞—á–∫–∞ —è–∫ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ–≥–æ
            forensic_data.deleted = True
            forensic_data.deletion_time = datetime.now()
            
            # –õ–æ–≥—É–≤–∞–Ω–Ω—è
            await self.security_monitor.log_event(
                "MEDIA_RECOVERED",
                "INFO",
                "ForensicSnapshot",
                f"–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ –≤–∏–¥–∞–ª–µ–Ω–µ –º–µ–¥—ñ–∞: {forensic_hash}"
            )
            
            return decrypted_data
            
        except Exception as e:
            await self.security_monitor.log_event(
                "MEDIA_RECOVERY_FAILED",
                "ERROR",
                "ForensicSnapshot",
                f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è: {str(e)}"
            )
            return None
    
    async def get_media_forensic_report(self, forensic_hash: str) -> Dict:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–≤—ñ—Ç—É –ø–æ –º–µ–¥—ñ–∞"""
        if forensic_hash not in self.media_registry:
            return {"error": "–ú–µ–¥—ñ–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ"}
        
        forensic_data = self.media_registry[forensic_hash]
        
        report = {
            "forensic_data": asdict(forensic_data),
            "analysis": {
                "integrity_check": self._verify_integrity(forensic_data),
                "tamper_detection": await self._detect_tampering(forensic_data),
                "metadata_timeline": await self._build_metadata_timeline(forensic_data),
                "similarity_search": await self._find_similar_media(forensic_data)
            }
        }
        
        return report
    
    def _verify_integrity(self, forensic_data: MediaForensicData) -> Dict:
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö"""
        try:
            with open(forensic_data.file_path, 'rb') as f:
                current_data = f.read()
            
            current_hash = hashlib.sha256(current_data).hexdigest()
            original_hash = forensic_data.original_hash
            
            return {
                "verified": current_hash == original_hash,
                "current_hash": current_hash,
                "original_hash": original_hash,
                "tampered": current_hash != original_hash
            }
        except Exception as e:
            return {"error": str(e), "verified": False}
    
    async def monitor_self_destruct_timers(self):
        """
        –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ç–∞–π–º–µ—Ä—ñ–≤ —Å–∞–º–æ–∑–Ω–∏—â–µ–Ω–Ω—è
        –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å—Ç–≤–æ—Ä—é—î –∫–æ–ø—ñ—ó –ø–µ—Ä–µ–¥ –≤–∏–¥–∞–ª–µ–Ω–Ω—è–º
        """
        while True:
            try:
                # –¢—É—Ç —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ Telegram API –¥–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è timer-based deletions
                # –°–∏–º—É–ª—é—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É
                await asyncio.sleep(10)  # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–∂–Ω—ñ 10 —Å–µ–∫—É–Ω–¥
                
                # –õ–æ–≥—ñ–∫–∞ –≤–∏—è–≤–ª–µ–Ω–Ω—è —Ç–∞–π–º–µ—Ä—ñ–≤ —Å–∞–º–æ–∑–Ω–∏—â–µ–Ω–Ω—è
                # (–ø–æ—Ç—Ä—ñ–±–Ω–æ —ñ–Ω—Ç–µ–≥—Ä—É–≤–∞—Ç–∏ –∑ —Ä–µ–∞–ª—å–Ω–∏–º API Telegram)
                
            except Exception as e:
                await self.security_monitor.log_event(
                    "SELF_DESTRUCT_MONITOR_ERROR",
                    "ERROR",
                    "ForensicSnapshot",
                    str(e)
                )
    
    async def export_forensic_package(self, forensic_hash: str, 
                                    output_format: str = "zip") -> str:
        """
        –ï–∫—Å–ø–æ—Ä—Ç —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –ø–∞–∫–µ—Ç—É –∑ —É—Å—ñ–º–∞ –¥–∞–Ω–∏–º–∏
        
        Returns:
            –®–ª—è—Ö –¥–æ –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ–≥–æ —Ñ–∞–π–ª—É
        """
        from zipfile import ZipFile
        import tempfile
        
        if forensic_hash not in self.media_registry:
            raise ValueError("–ú–µ–¥—ñ–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ")
        
        forensic_data = self.media_registry[forensic_hash]
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∏–º—á–∞—Å–æ–≤–æ—ó –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó
        with tempfile.TemporaryDirectory() as tmpdir:
            export_path = Path(tmpdir) / f"forensic_export_{forensic_hash}.zip"
            
            with ZipFile(export_path, 'w') as zipf:
                # –î–æ–¥–∞–≤–∞–Ω–Ω—è –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª—É
                zipf.write(forensic_data.file_path, "original.encrypted")
                
                # –î–æ–¥–∞–≤–∞–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
                metadata_path = Path(tmpdir) / "metadata.json"
                with open(metadata_path, 'w') as f:
                    json.dump(asdict(forensic_data), f, indent=2, default=str)
                zipf.write(str(metadata_path), "metadata.json")
                
                # –î–æ–¥–∞–≤–∞–Ω–Ω—è –∑–≤—ñ—Ç—É –∞–Ω–∞–ª—ñ–∑—É
                report = await self.get_media_forensic_report(forensic_hash)
                report_path = Path(tmpdir) / "analysis_report.json"
                with open(report_path, 'w') as f:
                    json.dump(report, f, indent=2, default=str)
                zipf.write(str(report_path), "analysis_report.json")
            
            return str(export_path)
```

–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ –≥–æ–ª–æ–≤–Ω–∏–º –±–æ—Ç–æ–º:

```python
# –í main.py –¥–æ–¥–∞—î–º–æ
from core.forensic_snapshot import ForensicSnapshot

# –í lifespan –¥–æ–¥–∞—î–º–æ
forensic_snapshot = ForensicSnapshot()
asyncio.create_task(forensic_snapshot.monitor_self_destruct_timers())

# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –∑–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –º–µ–¥—ñ–∞
@dp.message(F.content_type.in_({'photo', 'video', 'document', 'audio', 'voice', 'video_note'}))
async def handle_media_message(message: Message):
    """–ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –º–µ–¥—ñ–∞-–ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –¥–ª—è —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É"""
    
    # –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ñ–∞–π–ª—É
    file_id = None
    file_data = None
    
    if message.photo:
        file_id = message.photo[-1].file_id
    elif message.video:
        file_id = message.video.file_id
    elif message.document:
        file_id = message.document.file_id
    elif message.audio:
        file_id = message.audio.file_id
    elif message.voice:
        file_id = message.voice.file_id
    elif message.video_note:
        file_id = message.video_note.file_id
    
    if file_id:
        # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É
        file = await bot.get_file(file_id)
        file_data = await bot.download_file(file.file_path)
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–Ω—ñ–º–∫—É
        file_info = {
            'file_id': file_id,
            'file_size': file.file_size,
            'file_path': file.file_path,
            'mime_type': getattr(message, 'mime_type', 'unknown')
        }
        
        context = {
            'user_id': message.from_user.id,
            'chat_id': message.chat.id,
            'message_id': message.message_id,
            'timestamp': message.date
        }
        
        forensic_data = await forensic_snapshot.capture_media(
            file_data, 
            file_info, 
            context
        )
        
        # –õ–æ–≥—É–≤–∞–Ω–Ω—è
        logger.info(f"üì∏ –ó–∞—Ö–æ–ø–ª–µ–Ω–æ –º–µ–¥—ñ–∞: {forensic_data.forensic_hash}")
```

üß† 2. AI SENTIMENT MONITOR (–ê–ù–ê–õ–Ü–ó –ù–ê–°–¢–†–û–Æ)

core/ai_sentiment.py

```python
"""
AI Sentiment Monitor - –®–Ü –∞–Ω–∞–ª—ñ–∑ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∑–Ω–∞—á–∞—î –µ–º–æ—Ü—ñ—ó —Ç–∞ —Å–ø–æ–≤—ñ—â–∞—î –ø—Ä–æ –ø–∞–Ω—ñ–∫—É/–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
"""

import asyncio
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import numpy as np
from dataclasses import dataclass
from enum import Enum

# –Ü–º–ø–æ—Ä—Ç ML –±—ñ–±–ª—ñ–æ—Ç–µ–∫
try:
    from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification
    import torch
    TRANSFORMERS_AVAILABLE = True
except ImportError:
    TRANSFORMERS_AVAILABLE = False
    print("Transformers not available, using fallback sentiment analysis")

from services.ai_service import AIService
from core.security import SecurityMonitor
from utils.decorators import circuit_breaker, timing_decorator

class SentimentLabel(Enum):
    """–ú—ñ—Ç–∫–∏ –Ω–∞—Å—Ç—Ä–æ—é"""
    PANIC = "–ø–∞–Ω—ñ–∫–∞"
    AGGRESSION = "–∞–≥—Ä–µ—Å—ñ—è"
    FEAR = "—Å—Ç—Ä–∞—Ö"
    URGENCY = "—Ç–µ—Ä–º—ñ–Ω–æ–≤—ñ—Å—Ç—å"
    COORDINATES = "–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏"
    PLANNING = "–ø–ª–∞–Ω—É–≤–∞–Ω–Ω—è"
    NORMAL = "–Ω–æ—Ä–º–∞–ª—å–Ω–∏–π"
    POSITIVE = "–ø–æ–∑–∏—Ç–∏–≤–Ω–∏–π"
    NEGATIVE = "–Ω–µ–≥–∞—Ç–∏–≤–Ω–∏–π"
    NEUTRAL = "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∏–π"

@dataclass
class SentimentAnalysis:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª—ñ–∑—É –Ω–∞—Å—Ç—Ä–æ—é"""
    text: str
    sentiment: SentimentLabel
    confidence: float
    detected_emotions: List[Tuple[str, float]]
    keywords: List[str]
    urgency_level: int  # 0-10
    requires_attention: bool
    timestamp: datetime
    metadata: Dict

class AISentimentMonitor:
    """–ú–æ–Ω—ñ—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ—é –Ω–∞ –æ—Å–Ω–æ–≤—ñ –®–Ü"""
    
    def __init__(self, model_name: str = "cointegrated/rubert-tiny-sentiment-balanced"):
        self.model_name = model_name
        self.ai_service = AIService()
        self.security_monitor = SecurityMonitor()
        
        # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ
        self.sentiment_pipeline = None
        self.tokenizer = None
        self.model = None
        
        # –ö–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ –¥–ª—è –¥–µ—Ç–µ–∫—Ü—ñ—ó
        self.panic_keywords = [
            "—Ç–µ—Ä–º—ñ–Ω–æ–≤–æ", "—à–≤–∏–¥–∫–æ", "–Ω–µ–≥–∞–π–Ω–æ", "—Ä—è—Ç—É–π—Ç–µ", "–¥–æ–ø–æ–º–æ–∂—ñ—Ç—å",
            "–∞–≤–∞—Ä—ñ—è", "–∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞", "–∑–∞–≥—Ä–æ–∑–∞", "–Ω–µ–±–µ–∑–ø–µ–∫–∞", "—Ç—Ä–µ–≤–æ–≥–∞",
            "—Å—Ö–æ–≤–∞—Ç–∏—Å—è", "–≤—Ç–µ–∫—Ç–∏", "–µ–≤–∞–∫—É—é–≤–∞—Ç–∏", "–∞—Ç–∞–∫–∞", "–æ–±—Å—Ç—Ä—ñ–ª"
        ]
        
        self.coordinate_keywords = [
            "–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏", "—à–∏—Ä–æ—Ç–∞", "–¥–æ–≤–≥–æ—Ç–∞", "gps", "–ª–æ–∫–∞—Ü—ñ—è",
            "—Ç–æ—á–∫–∞", "–º—ñ—Å—Ü–µ", "–∞–¥—Ä–µ—Å–∞", "–≤—É–ª–∏—Ü—è", "–±—É–¥–∏–Ω–æ–∫",
            "49.", "50.", "51.", "52.", "53.",  # –®–∏—Ä–æ—Ç–∏ –£–∫—Ä–∞—ó–Ω–∏
            "23.", "24.", "25.", "26.", "27.",  # –î–æ–≤–≥–æ—Ç–∏ –£–∫—Ä–∞—ó–Ω–∏
        ]
        
        # –Ü—Å—Ç–æ—Ä—ñ—è –∞–Ω–∞–ª—ñ–∑—É
        self.analysis_history: List[SentimentAnalysis] = []
        self.alert_thresholds = {
            SentimentLabel.PANIC: 0.7,
            SentimentLabel.COORDINATES: 0.8,
            SentimentLabel.URGENCY: 0.6
        }
        
        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –º–æ–¥–µ–ª—ñ
        self._initialize_model()
    
    def _initialize_model(self):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è ML –º–æ–¥–µ–ª—ñ"""
        if TRANSFORMERS_AVAILABLE:
            try:
                self.sentiment_pipeline = pipeline(
                    "sentiment-analysis",
                    model=self.model_name,
                    tokenizer=self.model_name,
                    device=0 if torch.cuda.is_available() else -1
                )
                logger.info(f"‚úÖ Sentiment model loaded: {self.model_name}")
            except Exception as e:
                logger.error(f"‚ùå Failed to load sentiment model: {e}")
                self.sentiment_pipeline = None
        else:
            logger.warning("Transformers not available, using rule-based analysis")
    
    @timing_decorator
    @circuit_breaker(failure_threshold=3, reset_timeout=60)
    async def analyze_text(self, text: str, context: Dict = None) -> SentimentAnalysis:
        """
        –ê–Ω–∞–ª—ñ–∑ —Ç–µ–∫—Å—Ç—É –Ω–∞ –Ω–∞—Å—Ç—Ä—ñ–π —Ç–∞ –µ–º–æ—Ü—ñ—ó
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
            context: –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        
        Returns:
            SentimentAnalysis –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        """
        if context is None:
            context = {}
        
        # –û—á–∏—â–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç—É
        cleaned_text = self._preprocess_text(text)
        
        # –ë–∞–∑–æ–≤–∏–π –∞–Ω–∞–ª—ñ–∑
        sentiment_result = await self._get_sentiment(cleaned_text)
        emotions = await self._detect_emotions(cleaned_text)
        keywords = self._extract_keywords(cleaned_text)
        urgency = self._calculate_urgency(cleaned_text, emotions)
        
        # –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –Ω–∞—Å—Ç—Ä–æ—é
        main_sentiment = self._determine_main_sentiment(
            sentiment_result, 
            emotions, 
            keywords, 
            urgency
        )
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±—É —É–≤–∞–≥–∏
        requires_attention = self._requires_attention(
            main_sentiment, 
            urgency, 
            context
        )
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
        analysis = SentimentAnalysis(
            text=text,
            sentiment=main_sentiment,
            confidence=sentiment_result.get('confidence', 0.5),
            detected_emotions=emotions,
            keywords=keywords,
            urgency_level=urgency,
            requires_attention=requires_attention,
            timestamp=datetime.now(),
            metadata={
                "context": context,
                "model_used": self.model_name if self.sentiment_pipeline else "rule_based",
                "text_length": len(text),
                "word_count": len(text.split())
            }
        )
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ —ñ—Å—Ç–æ—Ä—ñ—é
        self.analysis_history.append(analysis)
        
        # –°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–∏ –ø–æ—Ç—Ä–µ–±—ñ
        if requires_attention:
            await self._trigger_alert(analysis, context)
        
        return analysis
    
    async def _get_sentiment(self, text: str) -> Dict:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –Ω–∞—Å—Ç—Ä–æ—é —á–µ—Ä–µ–∑ ML –∞–±–æ fallback"""
        
        # –°–ø—Ä–æ–±–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä
        if self.sentiment_pipeline and len(text) > 3:
            try:
                result = self.sentiment_pipeline(text)[0]
                return {
                    'label': result['label'],
                    'confidence': result['score']
                }
            except Exception as e:
                logger.warning(f"Transformers failed: {e}")
        
        # Fallback —á–µ—Ä–µ–∑ OpenAI –∞–±–æ rule-based
        if hasattr(self.ai_service, 'analyze_sentiment'):
            return await self.ai_service.analyze_sentiment(text)
        else:
            return self._rule_based_sentiment(text)
    
    def _rule_based_sentiment(self, text: str) -> Dict:
        """Rule-based –∞–Ω–∞–ª—ñ–∑ –Ω–∞—Å—Ç—Ä–æ—é"""
        text_lower = text.lower()
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–∞–Ω—ñ—á–Ω–∏—Ö –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤
        panic_score = sum(1 for word in self.panic_keywords if word in text_lower)
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        coordinate_score = sum(1 for word in self.coordinate_keywords if word in text_lower)
        
        # –ü—Ä–æ—Å—Ç–∏–π –∞–Ω–∞–ª—ñ–∑ –µ–º–æ—Ü—ñ–π
        positive_words = ['–¥–æ–±—Ä–µ', '—á—É–¥–æ–≤–æ', '—Å—É–ø–µ—Ä', '–∑–¥–æ—Ä–æ–≤–æ', '—É—Å–ø—ñ—Ö']
        negative_words = ['–ø–æ–≥–∞–Ω–æ', '–∂–∞—Ö–ª–∏–≤–æ', '–∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞', '–ø—Ä–æ–±–ª–µ–º–∞', '–Ω–µ–±–µ–∑–ø–µ–∫–∞']
        
        pos_score = sum(1 for word in positive_words if word in text_lower)
        neg_score = sum(1 for word in negative_words if word in text_lower)
        
        if panic_score > 2 or coordinate_score > 1:
            label = SentimentLabel.PANIC if panic_score > coordinate_score else SentimentLabel.COORDINATES
            confidence = min(0.9, (panic_score + coordinate_score) / 10)
        elif neg_score > pos_score:
            label = SentimentLabel.NEGATIVE
            confidence = neg_score / len(text.split()) * 10
        elif pos_score > neg_score:
            label = SentimentLabel.POSITIVE
            confidence = pos_score / len(text.split()) * 10
        else:
            label = SentimentLabel.NEUTRAL
            confidence = 0.5
        
        return {'label': label, 'confidence': confidence}
    
    async def _detect_emotions(self, text: str) -> List[Tuple[str, float]]:
        """–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –µ–º–æ—Ü—ñ–π —É —Ç–µ–∫—Å—Ç—ñ"""
        emotions = []
        
        # –°–ª–æ–≤–Ω–∏–∫ –µ–º–æ—Ü—ñ–π —Ç–∞ –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤
        emotion_patterns = {
            "—Å—Ç—Ä–∞—Ö": ['–±–æ—é—Å—å', '—Å—Ç—Ä–∞—à–Ω–æ', '–∑–ª—è–∫–∞–≤—Å—è', '–ø–µ—Ä–µ–ª—è–∫–∞–Ω–∏–π', '–∂–∞—Ö'],
            "–∑–ª—ñ—Å—Ç—å": ['–∑–ª–∏–π', '—Å–µ—Ä–¥–∏—Ç–∏–π', '–æ–±—É—Ä–µ–Ω–∏–π', '–ª—é—Ç–∏–π', '–¥—Ä–∞—Ç—É—î'],
            "—Ä–∞–¥—ñ—Å—Ç—å": ['—Ä–∞–¥—ñ—é', '—â–∞—Å–ª–∏–≤–∏–π', '–≤–µ—Å–µ–ª–æ', '—Ä–∞–¥—ñ—Å—Ç—å', '–µ–Ω—Ç—É–∑—ñ–∞–∑–º'],
            "—Å–º—É—Ç–æ–∫": ['—Å—É–º–Ω–æ', '–ø—Ä–∏–≥–Ω—ñ—á–µ–Ω–∏–π', '–∂–∞–ª—å', '—Ç—É–≥–∞', '–¥–µ–ø—Ä–µ—Å—ñ—è'],
            "–∑–¥–∏–≤—É–≤–∞–Ω–Ω—è": ['–≤–∞—É', '–æ–≥–æ', '–Ω–µ–π–º–æ–≤—ñ—Ä–Ω–æ', '–¥–∏–≤–Ω–æ', '–Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–æ'],
            "–æ—á—ñ–∫—É–≤–∞–Ω–Ω—è": ['—á–µ–∫–∞—é', '–æ—á—ñ–∫—É—é', '–ø–µ—Ä–µ–¥–±–∞—á–∞—é', '–ø—Ä–∏–≥–æ—Ç—É–≤–∞—Ç–∏—Å—è', '–≥–æ—Ç—É–≤–∞—Ç–∏—Å—è'],
        }
        
        text_lower = text.lower()
        for emotion, keywords in emotion_patterns.items():
            score = sum(1 for word in keywords if word in text_lower)
            if score > 0:
                emotions.append((emotion, score / len(keywords)))
        
        return emotions
    
    def _extract_keywords(self, text: str) -> List[str]:
        """–í–∏—Ç—è–≥–Ω–µ–Ω–Ω—è –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤"""
        words = text.lower().split()
        
        # –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è —Å—Ç–æ–ø-—Å–ª—ñ–≤
        stop_words = ['—ñ', '–≤', '–Ω–∞', '–∑', '—Ç–∞', '—â–æ', '—è–∫', '–¥–ª—è']
        keywords = [word for word in words if word not in stop_words and len(word) > 3]
        
        # –î–æ–¥–∞–≤–∞–Ω–Ω—è —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏—Ö –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤
        for word in words:
            if any(pattern in word for pattern in self.coordinate_keywords):
                keywords.append(word)
            if any(pattern in word for pattern in self.panic_keywords):
                keywords.append(word)
        
        return list(set(keywords))[:10]  # –£–Ω—ñ–∫–∞–ª—å–Ω—ñ, –º–∞–∫—Å–∏–º—É–º 10
    
    def _calculate_urgency(self, text: str, emotions: List[Tuple[str, float]]) -> int:
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ä—ñ–≤–Ω—è —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ—Å—Ç—ñ"""
        urgency = 0
        
        # –ü–∞–Ω—ñ—á–Ω—ñ —Å–ª–æ–≤–∞
        for keyword in self.panic_keywords:
            if keyword in text.lower():
                urgency += 2
        
        # –ï–º–æ—Ü—ñ—ó —Å—Ç—Ä–∞—Ö—É
        for emotion, score in emotions:
            if emotion == "—Å—Ç—Ä–∞—Ö" and score > 0.3:
                urgency += int(score * 3)
        
        # –ó–Ω–∞–∫–∏ –æ–∫–ª–∏–∫—É
        urgency += text.count('!') * 0.5
        
        # –í–µ–ª–∏–∫—ñ –ª—ñ—Ç–µ—Ä–∏ (–∫—Ä–∏–∫)
        if len(text) > 10:
            upper_ratio = sum(1 for c in text if c.isupper()) / len(text)
            if upper_ratio > 0.3:
                urgency += 2
        
        return min(10, int(urgency))
    
    def _determine_main_sentiment(self, sentiment_result: Dict, 
                                 emotions: List[Tuple[str, float]], 
                                 keywords: List[str], 
                                 urgency: int) -> SentimentLabel:
        """–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –Ω–∞—Å—Ç—Ä–æ—é"""
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
        coordinate_words = [kw for kw in keywords if any(coord in kw for coord in self.coordinate_keywords)]
        if coordinate_words and urgency > 5:
            return SentimentLabel.COORDINATES
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø–∞–Ω—ñ–∫—É
        panic_words = [kw for kw in keywords if any(panic in kw for panic in self.panic_keywords)]
        if panic_words or urgency > 7:
            return SentimentLabel.PANIC
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –∞–≥—Ä–µ—Å—ñ—é
        fear_score = sum(score for emotion, score in emotions if emotion == "—Å—Ç—Ä–∞—Ö")
        anger_score = sum(score for emotion, score in emotions if emotion == "–∑–ª—ñ—Å—Ç—å")
        
        if anger_score > 0.5:
            return SentimentLabel.AGGRESSION
        elif fear_score > 0.5:
            return SentimentLabel.FEAR
        elif urgency > 3:
            return SentimentLabel.URGENCY
        
        # –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è ML —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
        if isinstance(sentiment_result.get('label'), SentimentLabel):
            return sentiment_result['label']
        
        # Fallback
        label_str = str(sentiment_result.get('label', '')).lower()
        if 'pos' in label_str:
            return SentimentLabel.POSITIVE
        elif 'neg' in label_str:
            return SentimentLabel.NEGATIVE
        else:
            return SentimentLabel.NEUTRAL
    
    def _requires_attention(self, sentiment: SentimentLabel, 
                          urgency: int, context: Dict) -> bool:
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ –ø–æ—Ç—Ä—ñ–±–Ω–∞ —É–≤–∞–≥–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞"""
        
        # –ö—Ä–∏—Ç–∏—á–Ω—ñ —Å–∏—Ç—É–∞—Ü—ñ—ó
        if sentiment in [SentimentLabel.PANIC, SentimentLabel.COORDINATES]:
            return True
        
        # –í–∏—Å–æ–∫–∞ —Ç–µ—Ä–º—ñ–Ω–æ–≤—ñ—Å—Ç—å
        if urgency >= 7:
            return True
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç—É–∞–ª—å–Ω—ñ —Ñ–∞–∫—Ç–æ—Ä–∏
        if context.get('is_important_chat', False):
            return urgency >= 5
        
        # –ë–∞–≥–∞—Ç–æ –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏—Ö –µ–º–æ—Ü—ñ–π
        if sentiment == SentimentLabel.NEGATIVE and urgency >= 4:
            return True
        
        return False
    
    async def _trigger_alert(self, analysis: SentimentAnalysis, context: Dict):
        """–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –∫—Ä–∏—Ç–∏—á–Ω—É —Å–∏—Ç—É–∞—Ü—ñ—é"""
        
        alert_message = f"""
üö® <b>–°–ò–°–¢–ï–ú–ê –í–ò–Ø–í–ò–õ–ê –ö–†–ò–¢–ò–ß–ù–£ –°–ò–¢–£–ê–¶–Ü–Æ</b>

üìù <b>–¢–µ–∫—Å—Ç:</b> {analysis.text[:200]}...
üéØ <b>–ù–∞—Å—Ç—Ä—ñ–π:</b> {analysis.sentiment.value.upper()}
‚ö†Ô∏è <b>–¢–µ—Ä–º—ñ–Ω–æ–≤—ñ—Å—Ç—å:</b> {analysis.urgency_level}/10
üîç <b>–ö–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞:</b> {', '.join(analysis.keywords[:5])}

üë§ <b>–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á:</b> {context.get('user_id', '–ù–µ–≤—ñ–¥–æ–º–æ')}
üí¨ <b>–ß–∞—Ç:</b> {context.get('chat_id', '–ù–µ–≤—ñ–¥–æ–º–æ')}
‚è∞ <b>–ß–∞—Å:</b> {analysis.timestamp.strftime('%H:%M:%S')}

üõ°Ô∏è <i>–°–∏—Å—Ç–µ–º–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É –Ω–∞—Å—Ç—Ä–æ—é</i>
"""
        
        # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –∞–ª–µ—Ä—Ç—É
        await self.security_monitor.log_event(
            "SENTIMENT_ALERT",
            "CRITICAL" if analysis.urgency_level > 7 else "HIGH",
            "AISentimentMonitor",
            f"Critical sentiment detected: {analysis.sentiment.value}",
            user_id=context.get('user_id'),
            metadata={
                "urgency": analysis.urgency_level,
                "keywords": analysis.keywords,
                "confidence": analysis.confidence
            }
        )
    
    async def monitor_chat_sentiment(self, chat_id: int, window_size: int = 50):
        """
        –ù–µ–ø–µ—Ä–µ—Ä–≤–Ω–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –Ω–∞—Å—Ç—Ä–æ—é –≤ —á–∞—Ç—ñ
        
        Args:
            chat_id: ID —á–∞—Ç—É –¥–ª—è –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
            window_size: –†–æ–∑–º—ñ—Ä –≤—ñ–∫–Ω–∞ –∞–Ω–∞–ª—ñ–∑—É
        """
        
        sentiment_trend = []
        alert_cooldown = {}
        
        while True:
            try:
                # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å (–ø–æ—Ç—Ä—ñ–±–Ω–∞ —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ API)
                # messages = await get_recent_messages(chat_id, window_size)
                
                # –¢–∏–º—á–∞—Å–æ–≤–∞ —ñ–º—ñ—Ç–∞—Ü—ñ—è
                await asyncio.sleep(30)  # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–∂–Ω—ñ 30 —Å–µ–∫—É–Ω–¥
                
                # –ê–Ω–∞–ª—ñ–∑ —Ç—Ä–µ–Ω–¥—É
                if len(sentiment_trend) > 10:
                    recent_sentiments = sentiment_trend[-10:]
                    
                    # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ —Ä—ñ–∑–∫—ñ –∑–º—ñ–Ω–∏
                    if self._detect_sudden_change(recent_sentiments):
                        await self.security_monitor.log_event(
                            "SENTIMENT_SPIKE",
                            "HIGH",
                            "AISentimentMonitor",
                            f"Sudden sentiment change in chat {chat_id}"
                        )
                
            except Exception as e:
                logger.error(f"Chat sentiment monitoring error: {e}")
    
    def _detect_sudden_change(self, sentiments: List[SentimentAnalysis]) -> bool:
        """–í–∏—è–≤–ª–µ–Ω–Ω—è —Ä—ñ–∑–∫–æ—ó –∑–º—ñ–Ω–∏ –Ω–∞—Å—Ç—Ä–æ—é"""
        if len(sentiments) < 5:
            return False
        
        # –ê–Ω–∞–ª—ñ–∑ —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ—Å—Ç—ñ
        urgencies = [s.urgency_level for s in sentiments[-5:]]
        avg_urgency = sum(urgencies) / len(urgencies)
        
        # –†—ñ–∑–∫–µ –ø—ñ–¥–≤–∏—â–µ–Ω–Ω—è —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ—Å—Ç—ñ
        if avg_urgency > 5 and max(urgencies) - min(urgencies) > 4:
            return True
        
        # –ü–æ—è–≤–∞ –ø–∞–Ω—ñ–∫–∏
        panic_count = sum(1 for s in sentiments if s.sentiment == SentimentLabel.PANIC)
        if panic_count >= 2:
            return True
        
        return False
    
    async def generate_sentiment_report(self, chat_id: int, 
                                      hours: int = 24) -> Dict:
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑–≤—ñ—Ç—É –ø—Ä–æ –Ω–∞—Å—Ç—Ä—ñ–π"""
        
        # –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è —ñ—Å—Ç–æ—Ä—ñ—ó –∑–∞ —á–∞—Ç–æ–º —Ç–∞ —á–∞—Å–æ–º
        from datetime import timedelta
        cutoff = datetime.now() - timedelta(hours=hours)
        
        chat_history = [
            a for a in self.analysis_history
            if a.metadata.get('context', {}).get('chat_id') == chat_id
            and a.timestamp >= cutoff
        ]
        
        if not chat_history:
            return {"error": "No data available"}
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        sentiment_counts = {}
        urgency_sum = 0
        alert_count = 0
        
        for analysis in chat_history:
            sentiment = analysis.sentiment.value
            sentiment_counts[sentiment] = sentiment_counts.get(sentiment, 0) + 1
            urgency_sum += analysis.urgency_level
            if analysis.requires_attention:
                alert_count += 1
        
        # –¢–æ–ø –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤
        all_keywords = {}
        for analysis in chat_history:
            for keyword in analysis.keywords:
                all_keywords[keyword] = all_keywords.get(keyword, 0) + 1
        
        top_keywords = sorted(all_keywords.items(), key=lambda x: x[1], reverse=True)[:10]
        
        report = {
            "period_hours": hours,
            "total_messages": len(chat_history),
            "average_urgency": urgency_sum / len(chat_history),
            "alerts_triggered": alert_count,
            "sentiment_distribution": sentiment_counts,
            "top_keywords": dict(top_keywords),
            "timeline": [
                {
                    "time": a.timestamp.strftime('%H:%M'),
                    "sentiment": a.sentiment.value,
                    "urgency": a.urgency_level,
                    "text_preview": a.text[:100]
                }
                for a in chat_history[-20:]  # –û—Å—Ç–∞–Ω–Ω—ñ 20 –∑–∞–ø–∏—Å—ñ–≤
            ]
        }
        
        return report
```

–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ —Ö–µ–Ω–¥–ª–µ—Ä–∞–º–∏:

```python
# –í —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö –¥–æ–¥–∞—î–º–æ
from core.ai_sentiment import AISentimentMonitor

sentiment_monitor = AISentimentMonitor()

@dp.message(F.text)
async def analyze_message_sentiment(message: Message):
    """–ê–Ω–∞–ª—ñ–∑ –Ω–∞—Å—Ç—Ä–æ—é –∫–æ–∂–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
    
    # –ö–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
    context = {
        'user_id': message.from_user.id,
        'username': message.from_user.username,
        'chat_id': message.chat.id,
        'chat_type': message.chat.type,
        'message_id': message.message_id,
        'is_important_chat': message.chat.id in IMPORTANT_CHATS
    }
    
    # –ê–Ω–∞–ª—ñ–∑ —Ç–µ–∫—Å—Ç—É
    analysis = await sentiment_monitor.analyze_text(message.text, context)
    
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –¥–ª—è –∞–¥–º—ñ–Ω—ñ–≤
    if analysis.requires_attention:
        admins = await get_chat_admins(message.chat.id)
        for admin_id in admins:
            await bot.send_message(
                admin_id,
                f"‚ö†Ô∏è <b>–£–í–ê–ì–ê: –í–∏—è–≤–ª–µ–Ω–æ {analysis.sentiment.value.upper()} —É —á–∞—Ç—ñ {message.chat.id}</b>\n\n"
                f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {message.text[:200]}...\n"
                f"–¢–µ—Ä–º—ñ–Ω–æ–≤—ñ—Å—Ç—å: {analysis.urgency_level}/10",
                parse_mode="HTML"
            )
    
    # –õ–æ–≥—É–≤–∞–Ω–Ω—è
    logger.info(f"Sentiment: {analysis.sentiment.value} "
                f"(urgency: {analysis.urgency_level}) "
                f"for message from {message.from_user.id}")
```

üëª 3. ANTI-GHOST RECOVERY (–í–Ü–î–ù–û–í–õ–ï–ù–ù–Ø)

core/anti_ghost_recovery.py

```python
"""
Anti-Ghost Recovery - –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ —Ç–æ—á–Ω—ñ—Å—Ç—é 100%
–Ü–Ω–¥–µ–∫—Å—É—î –∫–æ–∂–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ –≤ –º–æ–º–µ–Ω—Ç –æ—Ç—Ä–∏–º–∞–Ω–Ω—è
"""

import asyncio
import hashlib
import pickle
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
import json
from collections import defaultdict

from redis import Redis
import msgpack

from utils.decorators import timing_decorator, circuit_breaker
from core.security import SecurityMonitor
from services.encryption import EncryptionService

@dataclass
class GhostMessage:
    """–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è"""
    message_id: int
    chat_id: int
    user_id: int
    text: Optional[str]
    media_type: Optional[str]
    media_data: Optional[bytes]
    timestamp: datetime
    deleted: bool = False
    deletion_time: Optional[datetime] = None
    recovery_count: int = 0
    metadata: Dict[str, Any] = None
    ghost_hash: str = ""  # –£–Ω—ñ–∫–∞–ª—å–Ω–∏–π —Ö–µ—à –¥–ª—è —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        if not self.ghost_hash:
            self.ghost_hash = self.generate_hash()
    
    def generate_hash(self) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —É–Ω—ñ–∫–∞–ª—å–Ω–æ–≥–æ —Ö–µ—à—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        content = f"{self.chat_id}:{self.message_id}:{self.timestamp.timestamp()}"
        return hashlib.sha256(content.encode()).hexdigest()

class AntiGhostRecovery:
    """
    –°–∏—Å—Ç–µ–º–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
    –Ü–Ω–¥–µ–∫—Å—É—î –≤—Å–µ –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ
    """
    
    def __init__(self, redis_url: str = None):
        # Redis –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –¥–æ—Å—Ç—É–ø—É
        self.redis = Redis.from_url(redis_url) if redis_url else None
        
        # –û–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞ –ø–∞–º'—è—Ç—å (in-memory –∫–µ—à)
        self.memory_cache: Dict[str, GhostMessage] = {}
        self.chat_index: Dict[int, List[str]] = defaultdict(list)
        self.user_index: Dict[int, List[str]] = defaultdict(list)
        
        # –°–µ—Ä–≤—ñ—Å–∏
        self.encryption = EncryptionService()
        self.security_monitor = SecurityMonitor()
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'total_captured': 0,
            'total_deleted': 0,
            'total_recovered': 0,
            'cache_hits': 0,
            'cache_misses': 0
        }
        
        # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
        self.cache_ttl = 3600  # 1 –≥–æ–¥–∏–Ω–∞ –≤ –ø–∞–º'—è—Ç—ñ
        self.max_cache_size = 100000  # –ú–∞–∫—Å–∏–º—É–º 100–∫ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
        
        # –ó–∞–ø—É—Å–∫ –æ—á–∏—â–µ–Ω–Ω—è –∫–µ—à—É
        asyncio.create_task(self._cache_cleanup_task())
    
    @circuit_breaker(failure_threshold=5, reset_timeout=30)
    async def capture_message(self, message_data: Dict) -> GhostMessage:
        """
        –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –º–æ–º–µ–Ω—Ç –æ—Ç—Ä–∏–º–∞–Ω–Ω—è
        
        Args:
            message_data: –î–∞–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        
        Returns:
            GhostMessage –∑ —É—Å—ñ–º–∞ –¥–∞–Ω–∏–º–∏
        """
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–±'—î–∫—Ç—É GhostMessage
        ghost_message = GhostMessage(
            message_id=message_data.get('message_id'),
            chat_id=message_data.get('chat_id'),
            user_id=message_data.get('user_id'),
            text=message_data.get('text'),
            media_type=message_data.get('media_type'),
            media_data=message_data.get('media_data'),
            timestamp=datetime.now(),
            metadata={
                'message_date': message_data.get('date'),
                'forward_from': message_data.get('forward_from'),
                'reply_to': message_data.get('reply_to_message_id'),
                'entities': message_data.get('entities', []),
                'caption': message_data.get('caption'),
                'has_media_spoiler': message_data.get('has_media_spoiler', False)
            }
        )
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ
        await self._store_in_memory(ghost_message)
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ Redis (—è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω–∏–π)
        if self.redis:
            await self._store_in_redis(ghost_message)
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –Ω–∞ –¥–∏—Å–∫ (—Ä–µ–∑–µ—Ä–≤–Ω–∞ –∫–æ–ø—ñ—è)
        await self._store_on_disk(ghost_message)
        
        # –Ü–Ω–¥–µ–∫—Å–∞—Ü—ñ—è
        self.chat_index[ghost_message.chat_id].append(ghost_message.ghost_hash)
        self.user_index[ghost_message.user_id].append(ghost_message.ghost_hash)
        
        # –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        self.stats['total_captured'] += 1
        
        # –õ–æ–≥—É–≤–∞–Ω–Ω—è
        await self.security_monitor.log_event(
            "MESSAGE_CAPTURED",
            "INFO",
            "AntiGhostRecovery",
            f"–ó–∞—Ö–æ–ø–ª–µ–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è {ghost_message.message_id}",
            user_id=ghost_message.user_id,
            metadata={
                'chat_id': ghost_message.chat_id,
                'ghost_hash': ghost_message.ghost_hash
            }
        )
        
        return ghost_message
    
    async def _store_in_memory(self, message: GhostMessage):
        """–ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ"""
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–æ–∑–º—ñ—Ä—É –∫–µ—à—É
        if len(self.memory_cache) >= self.max_cache_size:
            # –í–∏–¥–∞–ª–µ–Ω–Ω—è –Ω–∞–π—Å—Ç–∞—Ä—ñ—à–∏—Ö –∑–∞–ø–∏—Å—ñ–≤
            oldest_hashes = sorted(
                self.memory_cache.keys(),
                key=lambda h: self.memory_cache[h].timestamp
            )[:1000]  # –í–∏–¥–∞–ª—è—î–º–æ 1000 –Ω–∞–π—Å—Ç–∞—Ä—ñ—à–∏—Ö
            for h in oldest_hashes:
                del self.memory_cache[h]
        
        # –®–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è —á—É—Ç–ª–∏–≤–∏—Ö –¥–∞–Ω–∏—Ö
        if message.text:
            message.text = await self.encryption.encrypt_text(message.text)
        if message.media_data:
            message.media_data = await self.encryption.encrypt_data(message.media_data)
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è
        self.memory_cache[message.ghost_hash] = message
    
    async def _store_in_redis(self, message: GhostMessage):
        """–ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ Redis"""
        try:
            # –°–µ—Ä—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è
            message_dict = asdict(message)
            message_dict['timestamp'] = message.timestamp.isoformat()
            if message.deletion_time:
                message_dict['deletion_time'] = message.deletion_time.isoformat()
            
            # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è
            self.redis.setex(
                f"ghost:{message.ghost_hash}",
                self.cache_ttl * 2,  # TTL –≤ 2 —Ä–∞–∑–∏ –±—ñ–ª—å—à–µ
                msgpack.packb(message_dict)
            )
            
            # –î–æ–¥–∞—Ç–∫–æ–≤—ñ —ñ–Ω–¥–µ–∫—Å–∏
            self.redis.sadd(f"chat:{message.chat_id}:messages", message.ghost_hash)
            self.redis.sadd(f"user:{message.user_id}:messages", message.ghost_hash)
            
        except Exception as e:
            logger.error(f"Redis storage error: {e}")
    
    async def _store_on_disk(self, message: GhostMessage):
        """–†–µ–∑–µ—Ä–≤–Ω–µ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –Ω–∞ –¥–∏—Å–∫"""
        import aiofiles
        from pathlib import Path
        
        try:
            # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó
            backup_dir = Path("data/ghost_backup") / str(message.chat_id)
            backup_dir.mkdir(parents=True, exist_ok=True)
            
            # –®–ª—è—Ö –¥–æ —Ñ–∞–π–ª—É
            file_path = backup_dir / f"{message.ghost_hash}.ghost"
            
            # –°–µ—Ä—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è
            message_dict = asdict(message)
            message_dict['timestamp'] = message.timestamp.isoformat()
            
            # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è
            async with aiofiles.open(file_path, 'wb') as f:
                await f.write(pickle.dumps(message_dict))
                
        except Exception as e:
            logger.error(f"Disk storage error: {e}")
    
    async def detect_deleted_message(self, chat_id: int, message_id: int) -> bool:
        """
        –í–∏—è–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        
        Returns:
            True —è–∫—â–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –±—É–ª–æ –∑–∞—Ö–æ–ø–ª–µ–Ω–æ —ñ –≤–∏–¥–∞–ª–µ–Ω–æ
        """
        
        # –ü–æ—à—É–∫ —É –ø–∞–º'—è—Ç—ñ
        for ghost_hash in self.chat_index.get(chat_id, []):
            message = self.memory_cache.get(ghost_hash)
            if message and message.message_id == message_id:
                # –ü–æ–∑–Ω–∞—á–∫–∞ —è–∫ –≤–∏–¥–∞–ª–µ–Ω–æ–≥–æ
                message.deleted = True
                message.deletion_time = datetime.now()
                self.stats['total_deleted'] += 1
                
                # –°–ø–æ–≤—ñ—â–µ–Ω–Ω—è
                await self._notify_deletion(message)
                return True
        
        # –ü–æ—à—É–∫ –≤ Redis
        if self.redis:
            try:
                chat_messages = self.redis.smembers(f"chat:{chat_id}:messages")
                for ghost_hash_bytes in chat_messages:
                    ghost_hash = ghost_hash_bytes.decode()
                    message_data = self.redis.get(f"ghost:{ghost_hash}")
                    if message_data:
                        message_dict = msgpack.unpackb(message_data)
                        if message_dict.get('message_id') == message_id:
                            # –û–Ω–æ–≤–ª–µ–Ω–Ω—è –≤ –ø–∞–º'—è—Ç—ñ
                            message = GhostMessage(**message_dict)
                            message.deleted = True
                            message.deletion_time = datetime.now()
                            self.memory_cache[ghost_hash] = message
                            
                            self.stats['total_deleted'] += 1
                            await self._notify_deletion(message)
                            return True
            except Exception as e:
                logger.error(f"Redis deletion detection error: {e}")
        
        return False
    
    async def recover_message(self, chat_id: int, message_id: int) -> Optional[GhostMessage]:
        """
        –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        
        Returns:
            GhostMessage –∞–±–æ None
        """
        
        # –ü–æ—à—É–∫ –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ (–Ω–∞–π—à–≤–∏–¥—à–∏–π)
        for ghost_hash in self.chat_index.get(chat_id, []):
            message = self.memory_cache.get(ghost_hash)
            if message and message.message_id == message_id:
                self.stats['cache_hits'] += 1
                return await self._prepare_recovery(message)
        
        # –ü–æ—à—É–∫ –≤ Redis
        if self.redis:
            try:
                chat_messages = self.redis.smembers(f"chat:{chat_id}:messages")
                for ghost_hash_bytes in chat_messages:
                    ghost_hash = ghost_hash_bytes.decode()
                    message_data = self.redis.get(f"ghost:{ghost_hash}")
                    if message_data:
                        message_dict = msgpack.unpackb(message_data)
                        if message_dict.get('message_id') == message_id:
                            self.stats['cache_hits'] += 1
                            message = GhostMessage(**message_dict)
                            return await self._prepare_recovery(message)
            except Exception as e:
                logger.error(f"Redis recovery error: {e}")
        
        # –ü–æ—à—É–∫ –Ω–∞ –¥–∏—Å–∫—É
        message = await self._recover_from_disk(chat_id, message_id)
        if message:
            self.stats['cache_misses'] += 1
            return await self._prepare_recovery(message)
        
        return None
    
    async def _prepare_recovery(self, message: GhostMessage) -> GhostMessage:
        """–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–æ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è"""
        
        # –î–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è
        if message.text:
            message.text = await self.encryption.decrypt_text(message.text)
        if message.media_data:
            message.media_data = await self.encryption.decrypt_data(message.media_data)
        
        # –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        message.recovery_count += 1
        self.stats['total_recovered'] += 1
        
        # –õ–æ–≥—É–≤–∞–Ω–Ω—è
        await self.security_monitor.log_event(
            "MESSAGE_RECOVERED",
            "INFO",
            "AntiGhostRecovery",
            f"–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ –≤–∏–¥–∞–ª–µ–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è {message.message_id}",
            user_id=message.user_id,
            metadata={
                'chat_id': message.chat_id,
                'recovery_count': message.recovery_count,
                'was_deleted': message.deleted
            }
        )
        
        return message
    
    async def _recover_from_disk(self, chat_id: int, message_id: int) -> Optional[GhostMessage]:
        """–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –∑ –¥–∏—Å–∫–æ–≤–æ–≥–æ –±–µ–∫–∞–ø—É"""
        import aiofiles
        from pathlib import Path
        
        try:
            backup_dir = Path("data/ghost_backup") / str(chat_id)
            if not backup_dir.exists():
                return None
            
            # –ü–æ—à—É–∫ —É —Ñ–∞–π–ª–∞—Ö –±–µ–∫–∞–ø—É
            for file_path in backup_dir.glob("*.ghost"):
                async with aiofiles.open(file_path, 'rb') as f:
                    message_dict = pickle.loads(await f.read())
                
                if message_dict.get('message_id') == message_id:
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è timestamp
                    message_dict['timestamp'] = datetime.fromisoformat(message_dict['timestamp'])
                    if message_dict.get('deletion_time'):
                        message_dict['deletion_time'] = datetime.fromisoformat(
                            message_dict['deletion_time']
                        )
                    
                    return GhostMessage(**message_dict)
        
        except Exception as e:
            logger.error(f"Disk recovery error: {e}")
        
        return None
    
    async def _notify_deletion(self, message: GhostMessage):
        """–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –≤–∏–¥–∞–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        
        alert_message = f"""
üëª <b>–í–ò–Ø–í–õ–ï–ù–û –í–ò–î–ê–õ–ï–ù–ï –ü–û–í–Ü–î–û–ú–õ–ï–ù–ù–Ø</b>

üí¨ <b>–ß–∞—Ç:</b> {message.chat_id}
üë§ <b>–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á:</b> {message.user_id}
üìù <b>ID –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:</b> {message.message_id}
‚è∞ <b>–ß–∞—Å –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è:</b> {message.timestamp.strftime('%H:%M:%S')}
üïí <b>–ß–∞—Å –≤–∏–¥–∞–ª–µ–Ω–Ω—è:</b> {message.deletion_time.strftime('%H:%M:%S') if message.deletion_time else '–ù–µ–≤—ñ–¥–æ–º–æ'}

üîç <b>–¢–µ–∫—Å—Ç:</b> {(message.text[:200] + '...') if message.text else '[–ú–µ–¥—ñ–∞-–ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è]'}
üìä <b>–¢–∏–ø:</b> {message.media_type or '–¢–µ–∫—Å—Ç'}

üõ°Ô∏è <i>–°–∏—Å—Ç–µ–º–∞ Anti-Ghost Recovery</i>
"""
        
        # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∞–¥–º—ñ–Ω–∞–º
        admins = await self._get_chat_admins(message.chat_id)
        for admin_id in admins:
            try:
                # –¢—É—Ç –ø–æ—Ç—Ä—ñ–±–µ–Ω –¥–æ—Å—Ç—É–ø –¥–æ –±–æ—Ç–∞ –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏
                # await bot.send_message(admin_id, alert_message, parse_mode="HTML")
                pass
            except Exception as e:
                logger.error(f"Failed to notify admin {admin_id}: {e}")
        
        # –õ–æ–≥—É–≤–∞–Ω–Ω—è –≤ —Å–∏—Å—Ç–µ–º—É –±–µ–∑–ø–µ–∫–∏
        await self.security_monitor.log_event(
            "MESSAGE_DELETED_DETECTED",
            "MEDIUM",
            "AntiGhostRecovery",
            f"Message {message.message_id} deleted in chat {message.chat_id}",
            user_id=message.user_id,
            metadata={
                'text_preview': message.text[:100] if message.text else None,
                'media_type': message.media_type,
                'time_sent': message.timestamp.isoformat(),
                'time_deleted': message.deletion_time.isoformat() if message.deletion_time else None
            }
        )
    
    async def bulk_recover_chat(self, chat_id: int, limit: int = 100) -> List[GhostMessage]:
        """–ú–∞—Å–æ–≤–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ —á–∞—Ç—É"""
        recovered_messages = []
        
        # –ü–æ—à—É–∫ –≤ —ñ–Ω–¥–µ–∫—Å—ñ
        for ghost_hash in self.chat_index.get(chat_id, [])[:limit]:
            message = self.memory_cache.get(ghost_hash)
            if message and message.deleted:
                recovered = await self.recover_message(chat_id, message.message_id)
                if recovered:
                    recovered_messages.append(recovered)
        
        return recovered_messages
    
    async def get_recovery_stats(self) -> Dict:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è"""
        
        # –î–æ–¥–∞—Ç–∫–æ–≤—ñ –º–µ—Ç—Ä–∏–∫–∏
        active_chats = len(self.chat_index)
        active_users = len(self.user_index)
        cache_size = len(self.memory_cache)
        
        # –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
        if self.stats['total_deleted'] > 0:
            recovery_rate = (self.stats['total_recovered'] / self.stats['total_deleted']) * 100
        else:
            recovery_rate = 100.0
        
        if self.stats['cache_hits'] + self.stats['cache_misses'] > 0:
            cache_efficiency = (
                self.stats['cache_hits'] / 
                (self.stats['cache_hits'] + self.stats['cache_misses'])
            ) * 100
        else:
            cache_efficiency = 100.0
        
        return {
            **self.stats,
            'recovery_rate_percent': round(recovery_rate, 2),
            'cache_efficiency_percent': round(cache_efficiency, 2),
            'active_chats': active_chats,
            'active_users': active_users,
            'cache_size': cache_size,
            'max_cache_size': self.max_cache_size,
            'cache_utilization_percent': round((cache_size / self.max_cache_size) * 100, 2)
        }
    
    async def _cache_cleanup_task(self):
        """–§–æ–Ω–æ–≤–∞ –∑–∞–¥–∞—á–∞ –æ—á–∏—â–µ–Ω–Ω—è –∫–µ—à—É"""
        while True:
            try:
                await asyncio.sleep(300)  # –ö–æ–∂–Ω—ñ 5 —Ö–≤–∏–ª–∏–Ω
                await self._cleanup_old_messages()
            except Exception as e:
                logger.error(f"Cache cleanup error: {e}")
    
    async def _cleanup_old_messages(self):
        """–û—á–∏—â–µ–Ω–Ω—è —Å—Ç–∞—Ä–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∑ –∫–µ—à—É"""
        current_time = datetime.now()
        to_remove = []
        
        for ghost_hash, message in self.memory_cache.items():
            # –í–∏–¥–∞–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å —Å—Ç–∞—Ä—à–µ TTL
            age = (current_time - message.timestamp).total_seconds()
            if age > self.cache_ttl and not message.deleted:
                to_remove.append(ghost_hash)
        
        # –í–∏–¥–∞–ª–µ–Ω–Ω—è
        for ghost_hash in to_remove[:1000]:  # –ù–µ –±—ñ–ª—å—à–µ 1000 –∑–∞ —Ä–∞–∑
            del self.memory_cache[ghost_hash]
        
        if to_remove:
            logger.info(f"Cleaned up {len(to_remove)} old messages from cache")
    
    async def _get_chat_admins(self, chat_id: int) -> List[int]:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä—ñ–≤ —á–∞—Ç—É"""
        # –Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ Telegram API
        # –¢–∏–º—á–∞—Å–æ–≤–∞ –∑–∞–≥–ª—É—à–∫–∞
        return [123456789]  # –ü—Ä–∏–∫–ª–∞–¥ ID –∞–¥–º—ñ–Ω–∞
```

–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ —Ö–µ–Ω–¥–ª–µ—Ä–∞–º–∏:

```python
# –í —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö –¥–æ–¥–∞—î–º–æ
from core.anti_ghost_recovery import AntiGhostRecovery

ghost_recovery = AntiGhostRecovery(redis_url=REDIS_URL)

# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –∑–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –≤—Å—ñ—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
@dp.message()
async def capture_all_messages(message: Message):
    """–ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –∫–æ–∂–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –º–æ–∂–ª–∏–≤–æ–≥–æ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è"""
    
    message_data = {
        'message_id': message.message_id,
        'chat_id': message.chat.id,
        'user_id': message.from_user.id,
        'text': message.text or message.caption,
        'date': message.date,
        'forward_from': message.forward_from,
        'reply_to_message_id': message.reply_to_message.message_id if message.reply_to_message else None,
        'entities': [e.to_dict() for e in message.entities] if message.entities else [],
        'has_media_spoiler': getattr(message, 'has_media_spoiler', False)
    }
    
    # –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ç–∏–ø—É –º–µ–¥—ñ–∞
    if message.photo:
        message_data['media_type'] = 'photo'
        # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–µ–¥—ñ–∞ –º–æ–∂–µ –±—É—Ç–∏ resource-intensive
        # –ú–æ–∂–Ω–∞ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ
    elif message.video:
        message_data['media_type'] = 'video'
    elif message.document:
        message_data['media_type'] = 'document'
    elif message.audio:
        message_data['media_type'] = 'audio'
    elif message.voice:
        message_data['media_type'] = 'voice'
    elif message.video_note:
        message_data['media_type'] = 'video_note'
    else:
        message_data['media_type'] = None
    
    # –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    await ghost_recovery.capture_message(message_data)

# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
@dp.message(Command("recover"))
async def recover_deleted(message: Message):
    """–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å"""
    
    # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –≤–∏–¥–∞–ª–µ–Ω–∏—Ö
    recovered = await ghost_recovery.bulk_recover_chat(
        message.chat.id, 
        limit=10
    )
    
    if not recovered:
        await message.reply("üì≠ –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è")
        return
    
    # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
    for ghost_message in recovered:
        recovery_text = f"""
üîÆ <b>–í–Ü–î–ù–û–í–õ–ï–ù–û –í–ò–î–ê–õ–ï–ù–ï –ü–û–í–Ü–î–û–ú–õ–ï–ù–ù–Ø</b>

üë§ <i>–í—ñ–¥:</i> {ghost_message.user_id}
‚è∞ <i>–í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ:</i> {ghost_message.timestamp.strftime('%H:%M:%S')}
üîÑ <i>–í—ñ–¥–Ω–æ–≤–ª–µ–Ω—å:</i> {ghost_message.recovery_count}

{ghost_message.text or '[–ú–µ–¥—ñ–∞-–ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è]'}
"""
        
        await message.reply(recovery_text, parse_mode="HTML")
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    stats = await ghost_recovery.get_recovery_stats()
    stats_text = f"""
üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê –í–Ü–î–ù–û–í–õ–ï–ù–ù–Ø</b>

‚úÖ –ó–∞—Ö–æ–ø–ª–µ–Ω–æ: {stats['total_captured']}
üóëÔ∏è –í–∏–¥–∞–ª–µ–Ω–æ: {stats['total_deleted']}
üîÆ –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ: {stats['total_recovered']}
üéØ –ï—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å: {stats['recovery_rate_percent']}%
‚ö° –ö–µ—à: {stats['cache_efficiency_percent']}%
"""
    
    await message.reply(stats_text, parse_mode="HTML")
```

üî¨ 4. X-RAY METADATA TRACKING

core/xray_metadata.py

```python
"""
X-Ray Metadata Tracking - –ì–ª–∏–±–∏–Ω–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –∑–∞–ø–∏—Ç —á–µ—Ä–µ–∑ osint_engine –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è DC ID —Ç–∞ —ñ—Å—Ç–æ—Ä—ñ—ó –Ω—ñ–∫–Ω–µ–π–º—ñ–≤
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
import hashlib
import json

from core.osint_engine import AdvancedOSINTEngine
from core.security import SecurityMonitor
from services.encryption import EncryptionService
from utils.decorators import circuit_breaker, timing_decorator, failure_decorator

@dataclass
class DCInfo:
    """–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –¥–∞—Ç–∞-—Ü–µ–Ω—Ç—Ä Telegram"""
    dc_id: int
    location: str
    ip_range: List[str]
    owner: str
    security_level: str
    last_checked: datetime
    reliability_score: float  # 0.0-1.0

@dataclass
class UsernameHistory:
    """–Ü—Å—Ç–æ—Ä—ñ—è –∑–º—ñ–Ω–∏ –Ω—ñ–∫–Ω–µ–π–º—ñ–≤"""
    username: str
    first_seen: datetime
    last_seen: datetime
    usage_count: int
    associated_ips: List[str]
    metadata: Dict = field(default_factory=dict)

@dataclass
class XRayProfile:
    """–ü–æ–≤–Ω–∏–π –ø—Ä–æ—Ñ—ñ–ª—å –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞/—á–∞—Ç—É"""
    target_id: int
    target_type: str  # user, chat, channel
    dc_history: List[DCInfo]
    username_history: List[UsernameHistory]
    ip_history: List[Tuple[str, datetime]]
    metadata_fingerprint: str
    risk_score: float
    anomalies: List[str]
    last_updated: datetime

class XRayMetadataTracker:
    """–¢—Ä–µ–∫–µ—Ä –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –∑ –≥–ª–∏–±–∏–Ω–Ω–∏–º –∞–Ω–∞–ª—ñ–∑–æ–º"""
    
    def __init__(self):
        self.osint_engine = AdvancedOSINTEngine()
        self.security_monitor = SecurityMonitor()
        self.encryption = EncryptionService()
        
        # –ö–µ—à –ø—Ä–æ—Ñ—ñ–ª—ñ–≤
        self.profiles: Dict[str, XRayProfile] = {}
        
        # –ë–∞–∑–∏ –¥–∞–Ω–∏—Ö DC
        self.dc_database = self._load_dc_database()
        
        # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
        self.scan_depth = "deep"  # deep, medium, light
        self.enable_live_tracking = True
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'profiles_created': 0,
            'dc_queries': 0,
            'username_checks': 0,
            'anomalies_detected': 0
        }
    
    def _load_dc_database(self) -> Dict[int, DCInfo]:
        """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö DC"""
        # –ú–æ–∂–Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑ —Ñ–∞–π–ª—É –∞–±–æ API
        dc_db = {
            1: DCInfo(
                dc_id=1,
                location="Miami, USA",
                ip_range=["149.154.175.0/24"],
                owner="Telegram Inc.",
                security_level="high",
                last_checked=datetime.now(),
                reliability_score=0.95
            ),
            2: DCInfo(
                dc_id=2,
                location="Amsterdam, NL",
                ip_range=["149.154.167.0/24"],
                owner="Telegram Inc.",
                security_level="high",
                last_checked=datetime.now(),
                reliability_score=0.95
            ),
            3: DCInfo(
                dc_id=3,
                location="Miami, USA",
                ip_range=["149.154.175.0/24"],
                owner="Telegram Inc.",
                security_level="high",
                last_checked=datetime.now(),
                reliability_score=0.95
            ),
            4: DCInfo(
                dc_id=4,
                location="Amsterdam, NL",
                ip_range=["149.154.167.0/24"],
                owner="Telegram Inc.",
                security_level="high",
                last_checked=datetime.now(),
                reliability_score=0.95
            ),
            5: DCInfo(
                dc_id=5,
                location="Singapore, SG",
                ip_range=["91.108.56.0/24"],
                owner="Telegram Inc.",
                security_level="high",
                last_checked=datetime.now(),
                reliability_score=0.95
            )
        }
        
        return dc_db
    
    @timing_decorator
    @circuit_breaker(failure_threshold=3, reset_timeout=60)
    async def scan_target(self, target_id: int, target_type: str = "user") -> XRayProfile:
        """
        –ì–ª–∏–±–∏–Ω–Ω–µ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö —Ü—ñ–ª—ñ
        
        Args:
            target_id: ID —Ü—ñ–ª—ñ
            target_type: –¢–∏–ø —Ü—ñ–ª—ñ (user/chat/channel)
        
        Returns:
            XRayProfile –∑ —É—Å—ñ–º–∞ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏
        """
        
        profile_key = f"{target_type}_{target_id}"
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–µ—à—É
        if profile_key in self.profiles:
            profile = self.profiles[profile_key]
            # –û–Ω–æ–≤–ª–µ–Ω–Ω—è —è–∫—â–æ –ø—Ä–æ—Ñ—ñ–ª—å –∑–∞—Å—Ç–∞—Ä—ñ–≤
            if (datetime.now() - profile.last_updated).hours < 1:
                return profile
        
        # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –ø—Ä–æ—Ñ—ñ–ª—é
        profile = XRayProfile(
            target_id=target_id,
            target_type=target_type,
            dc_history=[],
            username_history=[],
            ip_history=[],
            metadata_fingerprint="",
            risk_score=0.0,
            anomalies=[],
            last_updated=datetime.now()
        )
        
        # –í–∏–∫–æ–Ω–∞–Ω–Ω—è —Å–∫–∞–Ω—É–≤–∞–Ω—å
        tasks = [
            self._scan_dc_info(target_id, target_type),
            self._scan_username_history(target_id, target_type),
            self._scan_ip_history(target_id, target_type),
            self._scan_behavior_patterns(target_id, target_type)
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # –û–±—Ä–æ–±–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                logger.error(f"Scan task {i} failed: {result}")
                continue
            
            if i == 0 and result:  # DC info
                profile.dc_history = result
            elif i == 1 and result:  # Username history
                profile.username_history = result
            elif i == 2 and result:  # IP history
                profile.ip_history = result
            elif i == 3 and result:  # Behavior patterns
                profile.risk_score = result.get('risk_score', 0.0)
                profile.anomalies = result.get('anomalies', [])
        
        # –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –≤—ñ–¥–±–∏—Ç–∫–∞
        profile.metadata_fingerprint = self._generate_fingerprint(profile)
        
        # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ –∫–µ—à
        self.profiles[profile_key] = profile
        self.stats['profiles_created'] += 1
        
        # –õ–æ–≥—É–≤–∞–Ω–Ω—è
        await self.security_monitor.log_event(
            "XRAY_SCAN_COMPLETED",
            "INFO",
            "XRayMetadataTracker",
            f"Scan completed for {target_type} {target_id}",
            metadata={
                'risk_score': profile.risk_score,
                'anomalies_count': len(profile.anomalies),
                'fingerprint': profile.metadata_fingerprint[:16]
            }
        )
        
        return profile
    
    async def _scan_dc_info(self, target_id: int, target_type: str) -> List[DCInfo]:
        """–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –¥–∞—Ç–∞-—Ü–µ–Ω—Ç—Ä"""
        
        dc_info_list = []
        
        try:
            # –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è osint_engine –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è DC ID
            # –¶–µ –º–æ–∂–µ –±—É—Ç–∏ —á–µ—Ä–µ–∑ –∞–Ω–∞–ª–∏–∑ IP, timing attacks, –∞–±–æ —ñ–Ω—à—ñ –º–µ—Ç–æ–¥–∏
            dc_data = await self.osint_engine.get_dc_info(target_id)
            
            if dc_data and 'dc_id' in dc_data:
                dc_id = dc_data['dc_id']
                
                # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–µ—Ç–∞–ª–µ–π DC –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
                if dc_id in self.dc_database:
                    dc_info = self.dc_database[dc_id]
                    dc_info.last_checked = datetime.now()
                    dc_info_list.append(dc_info)
                    
                    # –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
                    self.stats['dc_queries'] += 1
                else:
                    # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –∑–∞–ø–∏—Å—É DC
                    new_dc = DCInfo(
                        dc_id=dc_id,
                        location="Unknown",
                        ip_range=[],
                        owner="Unknown",
                        security_level="unknown",
                        last_checked=datetime.now(),
                        reliability_score=0.5
                    )
                    dc_info_list.append(new_dc)
            
            # –Ü—Å—Ç–æ—Ä–∏—á–Ω—ñ –¥–∞–Ω—ñ DC (—è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω—ñ)
            historical_dc = await self.osint_engine.get_dc_history(target_id)
            for hdc in historical_dc:
                if hdc['dc_id'] in self.dc_database:
                    dc_info_list.append(self.dc_database[hdc['dc_id']])
        
        except Exception as e:
            logger.error(f"DC scan error: {e}")
            await self.security_monitor.log_event(
                "DC_SCAN_ERROR",
                "ERROR",
                "XRayMetadataTracker",
                str(e)
            )
        
        return dc_info_list
    
    async def _scan_username_history(self, target_id: int, target_type: str) -> List[UsernameHistory]:
        """–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó –Ω—ñ–∫–Ω–µ–π–º—ñ–≤"""
        
        username_history = []
        
        try:
            # –û—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó —á–µ—Ä–µ–∑ osint_engine
            history_data = await self.osint_engine.get_username_history(target_id)
            
            for entry in history_data:
                username_entry = UsernameHistory(
                    username=entry.get('username', ''),
                    first_seen=datetime.fromisoformat(entry.get('first_seen', datetime.now().isoformat())),
                    last_seen=datetime.fromisoformat(entry.get('last_seen', datetime.now().isoformat())),
                    usage_count=entry.get('usage_count', 1),
                    associated_ips=entry.get('associated_ips', []),
                    metadata=entry.get('metadata', {})
                )
                username_history.append(username_entry)
            
            self.stats['username_checks'] += len(username_history)
            
            # –ê–Ω–∞–ª—ñ–∑ –∞–Ω–æ–º–∞–ª—ñ–π –≤ —ñ—Å—Ç–æ—Ä—ñ—ó
            anomalies = self._analyze_username_anomalies(username_history)
            if anomalies:
                await self.security_monitor.log_event(
                    "USERNAME_ANOMALIES",
                    "MEDIUM",
                    "XRayMetadataTracker",
                    f"Username anomalies for {target_id}: {anomalies}"
                )
        
        except Exception as e:
            logger.error(f"Username history scan error: {e}")
        
        return username_history
    
    def _analyze_username_anomalies(self, history: List[UsernameHistory]) -> List[str]:
        """–ê–Ω–∞–ª—ñ–∑ –∞–Ω–æ–º–∞–ª—ñ–π –≤ —ñ—Å—Ç–æ—Ä—ñ—ó –Ω—ñ–∫–Ω–µ–π–º—ñ–≤"""
        anomalies = []
        
        if not history:
            return anomalies
        
        # –ó–∞–Ω–∞–¥—Ç–æ —á–∞—Å—Ç—ñ –∑–º—ñ–Ω–∏
        if len(history) > 10:
            anomalies.append("–ß–∞—Å—Ç—ñ –∑–º—ñ–Ω–∏ –Ω—ñ–∫–Ω–µ–π–º—É (>10)")
        
        # –ê–Ω–∞–ª—ñ–∑ —á–∞—Å–æ–≤–∏—Ö –ø—Ä–æ–º—ñ–∂–∫—ñ–≤
        for i in range(1, len(history)):
            prev = history[i-1]
            curr = history[i]
            
            time_diff = (curr.first_seen - prev.last_seen).total_seconds()
            
            # –î—É–∂–µ —à–≤–∏–¥–∫–∞ –∑–º—ñ–Ω–∞ (< 1 —Ö–≤–∏–ª–∏–Ω–∞)
            if 0 < time_diff < 60:
                anomalies.append(f"–®–≤–∏–¥–∫–∞ –∑–º—ñ–Ω–∞ –Ω—ñ–∫–Ω–µ–π–º—É: {time_diff:.0f} —Å–µ–∫")
            
            # –ü—ñ–¥–æ–∑—Ä—ñ–ª—ñ –ø–∞—Ç–µ—Ä–Ω–∏
            if self._is_suspicious_pattern(prev.username, curr.username):
                anomalies.append(f"–ü—ñ–¥–æ–∑—Ä—ñ–ª–∞ –∑–º—ñ–Ω–∞: {prev.username} -> {curr.username}")
        
        # –ê–Ω–∞–ª—ñ–∑ —Å—Ö–æ–∂–æ—Å—Ç—ñ –∑ –≤—ñ–¥–æ–º–∏–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏
        for entry in history:
            if self._matches_threat_pattern(entry.username):
                anomalies.append(f"–ù—ñ–∫–Ω–µ–π–º –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –∑–∞–≥—Ä–æ–∑–ª–∏–≤–æ–º—É —à–∞–±–ª–æ–Ω—É: {entry.username}")
        
        return anomalies
    
    def _is_suspicious_pattern(self, old_username: str, new_username: str) -> bool:
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø—ñ–¥–æ–∑—Ä—ñ–ª—ñ –ø–∞—Ç–µ—Ä–Ω–∏ –∑–º—ñ–Ω–∏"""
        suspicious_patterns = [
            # –î–æ–¥–∞–≤–∞–Ω–Ω—è/–≤–∏–¥–∞–ª–µ–Ω–Ω—è —Ü–∏—Ñ—Ä
            (r'^(\D+)(\d+)$', r'^\1$'),
            (r'^(\D+)$', r'^\1\d+$'),
            
            # –ó–º—ñ–Ω–∞ —Ä–µ–≥—ñ—Å—Ç—Ä—É
            (r'^([a-z]+)$', r'^\1$', lambda o, n: o != n and o.lower() == n.lower()),
            
            # –ó–∞–º—ñ–Ω–∞ —Å—Ö–æ–∂–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤ (l -> 1, o -> 0)
            (r'[lo]', r'[10]'),
        ]
        
        import re
        
        for pattern in suspicious_patterns:
            if len(pattern) == 2:
                if re.match(pattern[0], old_username) and re.match(pattern[1], new_username):
                    return True
            elif len(pattern) == 3 and pattern[2](old_username, new_username):
                return True
        
        return False
    
    def _matches_threat_pattern(self, username: str) -> bool:
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ –∑–∞–≥—Ä–æ–∑–ª–∏–≤–∏–º —à–∞–±–ª–æ–Ω–∞–º"""
        threat_patterns = [
            r'.*admin.*', r'.*support.*', r'.*help.*',  # –Ü–º—ñ—Ç–∞—Ü—ñ—è —Å–ª—É–∂–±–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏
            r'.*official.*', r'.*telegram.*', r'.*bot.*',  # –Ü–º—ñ—Ç–∞—Ü—ñ—è –æ—Ñ—ñ—Ü—ñ–π–Ω–∏—Ö –∞–∫–∞—É–Ω—Ç—ñ–≤
            r'.*[0-9]{10}.*',  # –ù–æ–º–µ—Ä–∏ —Ç–µ–ª–µ—Ñ–æ–Ω—ñ–≤
            r'.*@.*\..*',  # Email-–∞–¥—Ä–µ—Å–∏
        ]
        
        import re
        
        for pattern in threat_patterns:
            if re.match(pattern, username, re.IGNORECASE):
                return True
        
        return False
    
    async def _scan_ip_history(self, target_id: int, target_type: str) -> List[Tuple[str, datetime]]:
        """–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó IP-–∞–¥—Ä–µ—Å"""
        
        ip_history = []
        
        try:
            # –û—Ç—Ä–∏–º–∞–Ω–Ω—è IP —ñ—Å—Ç–æ—Ä—ñ—ó —á–µ—Ä–µ–∑ osint_engine
            ip_data = await self.osint_engine.get_ip_history(target_id)
            
            for entry in ip_data:
                ip = entry.get('ip')
                timestamp = datetime.fromisoformat(entry.get('timestamp', datetime.now().isoformat()))
                
                if ip and self._is_valid_ip(ip):
                    ip_history.append((ip, timestamp))
            
            # –ì–µ–æ–ª–æ–∫–∞—Ü—ñ—è IP
            for ip, timestamp in ip_history[:10]:  # –û–±–º–µ–∂—É—î–º–æ –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
                geo_data = await self.osint_engine.geolocate_ip(ip)
                if geo_data:
                    # –ú–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –≤ –º–µ—Ç–∞–¥–∞–Ω—ñ
                    pass
        
        except Exception as e:
            logger.error(f"IP history scan error: {e}")
        
        return ip_history
    
    def _is_valid_ip(self, ip: str) -> bool:
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∞–ª—ñ–¥–Ω–æ—Å—Ç—ñ IP –∞–¥—Ä–µ—Å–∏"""
        import re
        
        ipv4_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
        ipv6_pattern = r'^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$'
        
        return bool(re.match(ipv4_pattern, ip) or re.match(ipv6_pattern, ip))
    
    async def _scan_behavior_patterns(self, target_id: int, target_type: str) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑ –ø–æ–≤–µ–¥—ñ–Ω–∫–æ–≤–∏—Ö –ø–∞—Ç–µ—Ä–Ω—ñ–≤"""
        
        behavior_data = {
            'risk_score': 0.0,
            'anomalies': [],
            'patterns': []
        }
        
        try:
            # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
            activity_data = await self.osint_engine.get_activity_patterns(target_id)
            
            if activity_data:
                # –ê–Ω–∞–ª—ñ–∑ —á–∞—Å—É –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
                time_anomalies = self._analyze_time_patterns(activity_data.get('time_patterns', []))
                if time_anomalies:
                    behavior_data['anomalies'].extend(time_anomalies)
                    behavior_data['risk_score'] += 0.2
                
                # –ê–Ω–∞–ª—ñ–∑ —á–∞—Å—Ç–æ—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
                frequency_anomalies = self._analyze_frequency_patterns(
                    activity_data.get('message_frequency', [])
                )
                if frequency_anomalies:
                    behavior_data['anomalies'].extend(frequency_anomalies)
                    behavior_data['risk_score'] += 0.3
                
                # –ê–Ω–∞–ª—ñ–∑ –∫–æ–Ω—Ç–µ–Ω—Ç—É
                content_anomalies = self._analyze_content_patterns(
                    activity_data.get('content_patterns', [])
                )
                if content_anomalies:
                    behavior_data['anomalies'].extend(content_anomalies)
                    behavior_data['risk_score'] += 0.5
            
            # –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è risk_score –¥–æ 1.0
            behavior_data['risk_score'] = min(1.0, behavior_data['risk_score'])
            
            # –õ–æ–≥—É–≤–∞–Ω–Ω—è –≤–∏—Å–æ–∫–æ–≥–æ —Ä–∏–∑–∏–∫—É
            if behavior_data['risk_score'] > 0.7:
                await self.security_monitor.log_event(
                    "HIGH_RISK_BEHAVIOR",
                    "HIGH",
                    "XRayMetadataTracker",
                    f"High risk behavior detected for {target_id}: "
                    f"score={behavior_data['risk_score']}",
                    metadata={'anomalies': behavior_data['anomalies']}
                )
                self.stats['anomalies_detected'] += 1
        
        except Exception as e:
            logger.error(f"Behavior pattern scan error: {e}")
        
        return behavior_data
    
    def _analyze_time_patterns(self, time_patterns: List) -> List[str]:
        """–ê–Ω–∞–ª—ñ–∑ –∞–Ω–æ–º–∞–ª—ñ–π —É —á–∞—Å—ñ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        anomalies = []
        
        if not time_patterns:
            return anomalies
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –≤ –Ω–µ–Ω–æ—Ä–º–∞–ª—å–Ω–∏–π —á–∞—Å
        for pattern in time_patterns:
            hour = pattern.get('hour', 0)
            
            # –ê–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –º—ñ–∂ 2:00 —Ç–∞ 5:00 (–Ω–æ—Ä–º–∞ –¥–ª—è –±–æ—Ç—ñ–≤, –∞–Ω–æ–º–∞–ª—ñ—è –¥–ª—è –ª—é–¥–µ–π)
            if 2 <= hour <= 5:
                anomalies.append(f"–ê–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —É –Ω—ñ—á–Ω–∏–π —á–∞—Å: {hour}:00")
            
            # –î—É–∂–µ –∫–æ—Ä–æ—Ç–∫—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏ –º—ñ–∂ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é
            interval = pattern.get('interval_minutes', 0)
            if 0 < interval < 1:  # –ú–µ–Ω—à–µ 1 —Ö–≤–∏–ª–∏–Ω–∏
                anomalies.append(f"–ù–∞–¥—Ç–æ —á–∞—Å—Ç—ñ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ: —ñ–Ω—Ç–µ—Ä–≤–∞–ª {interval} —Ö–≤")
        
        return anomalies
    
    def _generate_fingerprint(self, profile: XRayProfile) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –≤—ñ–¥–±–∏—Ç–∫–∞ –ø—Ä–æ—Ñ—ñ–ª—é"""
        
        fingerprint_data = {
            'target_id': profile.target_id,
            'target_type': profile.target_type,
            'dc_ids': [dc.dc_id for dc in profile.dc_history],
            'usernames': [u.username for u in profile.username_history],
            'ip_count': len(profile.ip_history),
            'risk_score': profile.risk_score,
            'anomaly_count': len(profile.anomalies)
        }
        
        # –°–µ—Ä—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–∞ —Ö–µ—à—É–≤–∞–Ω–Ω—è
        data_str = json.dumps(fingerprint_data, sort_keys=True)
        return hashlib.sha256(data_str.encode()).hexdigest()
    
    async def monitor_live_changes(self, target_id: int, target_type: str):
        """
        –ñ–∏–≤–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –∑–º—ñ–Ω –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
        
        Args:
            target_id: ID —Ü—ñ–ª—ñ –¥–ª—è –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
        """
        
        last_profile = None
        check_interval = 300  # 5 —Ö–≤–∏–ª–∏–Ω
        
        while self.enable_live_tracking:
            try:
                # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –ø—Ä–æ—Ñ—ñ–ª—é
                current_profile = await self.scan_target(target_id, target_type)
                
                # –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–º
                if last_profile:
                    changes = self._detect_changes(last_profile, current_profile)
                    
                    if changes:
                        # –°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –∑–º—ñ–Ω–∏
                        await self._notify_changes(
                            target_id, 
                            target_type, 
                            changes, 
                            current_profile
                        )
                
                last_profile = current_profile
                
                # –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –ø–µ—Ä–µ–¥ –Ω–∞—Å—Ç—É–ø–Ω–æ—é –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é
                await asyncio.sleep(check_interval)
                
            except Exception as e:
                logger.error(f"Live monitoring error: {e}")
                await asyncio.sleep(60)  # –ö–æ—Ä–æ—Ç—à–∞ –ø–∞—É–∑–∞ –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ
    
    def _detect_changes(self, old_profile: XRayProfile, 
                       new_profile: XRayProfile) -> Dict:
        """–í–∏—è–≤–ª–µ–Ω–Ω—è –∑–º—ñ–Ω –º—ñ–∂ –ø—Ä–æ—Ñ—ñ–ª—è–º–∏"""
        
        changes = {
            'dc_changed': False,
            'username_changed': False,
            'ip_changed': False,
            'fingerprint_changed': False,
            'risk_score_changed': False,
            'details': []
        }
        
        # –ó–º—ñ–Ω–∏ DC
        old_dc_ids = {dc.dc_id for dc in old_profile.dc_history}
        new_dc_ids = {dc.dc_id for dc in new_profile.dc_history}
        
        if old_dc_ids != new_dc_ids:
            changes['dc_changed'] = True
            changes['details'].append(
                f"DC –∑–º—ñ–Ω–∏–≤—Å—è: {old_dc_ids} -> {new_dc_ids}"
            )
        
        # –ó–º—ñ–Ω–∏ –Ω—ñ–∫–Ω–µ–π–º—É
        old_usernames = {u.username for u in old_profile.username_history}
        new_usernames = {u.username for u in new_profile.username_history}
        
        if new_usernames - old_usernames:
            changes['username_changed'] = True
            changes['details'].append(
                f"–ù–æ–≤–∏–π –Ω—ñ–∫–Ω–µ–π–º: {(new_usernames - old_usernames).pop()}"
            )
        
        # –ó–º—ñ–Ω–∏ IP
        old_ips = {ip for ip, _ in old_profile.ip_history}
        new_ips = {ip for ip, _ in new_profile.ip_history}
        
        if new_ips - old_ips:
            changes['ip_changed'] = True
            changes['details'].append(
                f"–ù–æ–≤–∏–π IP: {', '.join(new_ips - old_ips)}"
            )
        
        # –ó–º—ñ–Ω–∏ –≤—ñ–¥–±–∏—Ç–∫–∞
        if old_profile.metadata_fingerprint != new_profile.metadata_fingerprint:
            changes['fingerprint_changed'] = True
        
        # –ó–º—ñ–Ω–∏ —Ä–∏–∑–∏–∫—É
        risk_diff = abs(old_profile.risk_score - new_profile.risk_score)
        if risk_diff > 0.1:
            changes['risk_score_changed'] = True
            changes['details'].append(
                f"–†–∏–∑–∏–∫ –∑–º—ñ–Ω–∏–≤—Å—è: {old_profile.risk_score:.2f} -> {new_profile.risk_score:.2f}"
            )
        
        return changes
    
    async def _notify_changes(self, target_id: int, target_type: str, 
                            changes: Dict, profile: XRayProfile):
        """–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –∑–º—ñ–Ω–∏ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö"""
        
        if not any(changes.values()):
            return
        
        alert_message = f"""
üîç <b>–í–ò–Ø–í–õ–ï–ù–û –ó–ú–Ü–ù–ò –ú–ï–¢–ê–î–ê–ù–ù–ò–•</b>

üéØ <b>–¶—ñ–ª—å:</b> {target_type} {target_id}
‚è∞ <b>–ß–∞—Å:</b> {datetime.now().strftime('%H:%M:%S')}

üìä <b>–ó–º—ñ–Ω–∏:</b>
"""
        
        for detail in changes.get('details', []):
            alert_message += f"‚Ä¢ {detail}\n"
        
        alert_message += f"""
üõ°Ô∏è <b>–ü–æ—Ç–æ—á–Ω–∏–π —Ä–∏–∑–∏–∫:</b> {profile.risk_score:.2f}/1.0
üî¢ <b>–í—ñ–¥–±–∏—Ç–æ–∫:</b> {profile.metadata_fingerprint[:16]}...
"""
        
        # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è
        await self.security_monitor.log_event(
            "METADATA_CHANGES",
            "MEDIUM" if profile.risk_score < 0.7 else "HIGH",
            "XRayMetadataTracker",
            f"Metadata changes for {target_type} {target_id}",
            metadata={
                'changes': changes,
                'current_risk': profile.risk_score,
                'fingerprint': profile.metadata_fingerprint
            }
        )
    
    async def generate_xray_report(self, target_id: int, 
                                 target_type: str = "user") -> Dict:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –∑–≤—ñ—Ç—É X-Ray
        
        Returns:
            –°–ª–æ–≤–Ω–∏–∫ –∑ —É—Å—ñ–º–∞ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏ —Ç–∞ –∞–Ω–∞–ª—ñ–∑–æ–º
        """
        
        # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—Ä–æ—Ñ—ñ–ª—é
        profile = await self.scan_target(target_id, target_type)
        
        # –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –∞–Ω–∞–ª—ñ–∑
        threat_assessment = await self._assess_threat_level(profile)
        
        # –ü–æ–±—É–¥–æ–≤–∞ –∑–≤—ñ—Ç—É
        report = {
            'summary': {
                'target_id': profile.target_id,
                'target_type': profile.target_type,
                'scan_timestamp': profile.last_updated.isoformat(),
                'metadata_fingerprint': profile.metadata_fingerprint,
                'overall_risk_score': profile.risk_score,
                'threat_level': threat_assessment.get('level', 'UNKNOWN'),
                'confidence': threat_assessment.get('confidence', 0.0)
            },
            'dc_analysis': {
                'current_dc': profile.dc_history[-1] if profile.dc_history else None,
                'dc_history': [
                    {
                        'dc_id': dc.dc_id,
                        'location': dc.location,
                        'security_level': dc.security_level,
                        'last_checked': dc.last_checked.isoformat()
                    }
                    for dc in profile.dc_history
                ],
                'dc_anomalies': self._analyze_dc_anomalies(profile.dc_history)
            },
            'username_analysis': {
                'current_username': profile.username_history[-1].username if profile.username_history else None,
                'username_history': [
                    {
                        'username': u.username,
                        'first_seen': u.first_seen.isoformat(),
                        'last_seen': u.last_seen.isoformat(),
                        'usage_count': u.usage_count
                    }
                    for u in profile.username_history
                ],
                'username_anomalies': profile.anomalies
            },
            'ip_analysis': {
                'recent_ips': [
                    {'ip': ip, 'timestamp': ts.isoformat()}
                    for ip, ts in profile.ip_history[:10]  # –û—Å—Ç–∞–Ω–Ω—ñ 10
                ],
                'unique_ip_count': len(set(ip for ip, _ in profile.ip_history)),
                'ip_geolocation': await self._geolocate_ips(profile.ip_history)
            },
            'recommendations': threat_assessment.get('recommendations', []),
            'statistics': self.stats
        }
        
        return report
    
    async def _assess_threat_level(self, profile: XRayProfile) -> Dict:
        """–û—Ü—ñ–Ω–∫–∞ —Ä—ñ–≤–Ω—è –∑–∞–≥—Ä–æ–∑–∏"""
        
        threat_score = profile.risk_score
        anomalies_count = len(profile.anomalies)
        
        # –§–∞–∫—Ç–æ—Ä–∏ –∑–∞–≥—Ä–æ–∑–∏
        if anomalies_count > 5:
            threat_score += 0.2
        if len(profile.dc_history) > 3:
            threat_score += 0.1
        if len(set(u.username for u in profile.username_history)) > 8:
            threat_score += 0.15
        
        # –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ä—ñ–≤–Ω—è
        if threat_score >= 0.8:
            level = "CRITICAL"
            confidence = 0.9
            recommendations = [
                "–ù–µ–≥–∞–π–Ω–µ –±–ª–æ–∫—É–≤–∞–Ω–Ω—è",
                "–ü–æ–≤–Ω–∏–π –∞—É–¥–∏—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ",
                "–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ü—ñ—ó"
            ]
        elif threat_score >= 0.6:
            level = "HIGH"
            confidence = 0.75
            recommendations = [
                "–ü—ñ–¥–≤–∏—â–µ–Ω–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥",
                "–û–±–º–µ–∂–µ–Ω–Ω—è –¥–æ—Å—Ç—É–ø—É",
                "–†–µ–≥—É–ª—è—Ä–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏"
            ]
        elif threat_score >= 0.4:
            level = "MEDIUM"
            confidence = 0.6
            recommendations = [
                "–ü–µ—Ä—ñ–æ–¥–∏—á–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏",
                "–õ–æ–≥—É–≤–∞–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ",
                "–£–≤–∞–≥–∞ –¥–æ –Ω–æ–≤–∏—Ö –∞–Ω–æ–º–∞–ª—ñ–π"
            ]
        elif threat_score >= 0.2:
            level = "LOW"
            confidence = 0.4
            recommendations = [
                "–ë–∞–∑–æ–≤–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥",
                "–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—Ä–∏ –ø—ñ–¥–æ–∑—Ä—ñ–ª—ñ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"
            ]
        else:
            level = "NONE"
            confidence = 0.3
            recommendations = [
                "–†—É—Ç–∏–Ω–Ω–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥"
            ]
        
        return {
            'level': level,
            'score': threat_score,
            'confidence': confidence,
            'anomalies_count': anomalies_count,
            'recommendations': recommendations
        }
```

–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ —Ö–µ–Ω–¥–ª–µ—Ä–∞–º–∏:

```python
# –í —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö –¥–æ–¥–∞—î–º–æ
from core.xray_metadata import XRayMetadataTracker

xray_tracker = XRayMetadataTracker()

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
@dp.message(Command("xray"))
async def xray_scan(message: Message):
    """–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∞–±–æ —á–∞—Ç—É"""
    
    # –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ü—ñ–ª—ñ –∑ –∞—Ä–≥—É–º–µ–Ω—Ç—ñ–≤ –∫–æ–º–∞–Ω–¥–∏
    args = message.text.split()
    if len(args) < 2:
        await message.reply("–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: /xray <user_id –∞–±–æ @username>")
        return
    
    target = args[1]
    
    # –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ç–∏–ø—É —Ü—ñ–ª—ñ
    if target.startswith('@'):
        target_type = "user"
        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è @username –≤ ID (–ø–æ—Ç—Ä—ñ–±–Ω–∞ —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ API)
        target_id = await resolve_username(target[1:])
    else:
        try:
            target_id = int(target)
            target_type = "user" if target_id > 0 else "chat"
        except ValueError:
            await message.reply("‚ùå –ù–µ–≤—ñ—Ä–Ω–∏–π ID. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —á–∏—Å–ª–æ–≤–∏–π ID –∞–±–æ @username")
            return
    
    # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–æ—á–∞—Ç–æ–∫ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è
    status_msg = await message.reply("üîç <b>–ü–æ—á–∞—Ç–æ–∫ X-Ray —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è...</b>", parse_mode="HTML")
    
    try:
        # –í–∏–∫–æ–Ω–∞–Ω–Ω—è —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è
        profile = await xray_tracker.scan_target(target_id, target_type)
        
        # –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑–≤—ñ—Ç—É
        report = await xray_tracker.generate_xray_report(target_id, target_type)
        
        # –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
        result_message = f"""
üî¨ <b>X-RAY –ó–í–Ü–¢: {target}</b>

üéØ <b>–¢–∏–ø:</b> {report['summary']['target_type']}
üÜî <b>ID:</b> {report['summary']['target_id']}
‚è∞ <b>–°–∫–∞–Ω–æ–≤–∞–Ω–æ:</b> {report['summary']['scan_timestamp']}

‚ö†Ô∏è <b>–†—ñ–≤–µ–Ω—å —Ä–∏–∑–∏–∫—É:</b> {report['summary']['overall_risk_score']:.2f}/1.0
üõ°Ô∏è <b>–†—ñ–≤–µ–Ω—å –∑–∞–≥—Ä–æ–∑–∏:</b> {report['summary']['threat_level']}
üéØ <b>–í–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å:</b> {report['summary']['confidence']:.0%}

üì° <b>–î–∞—Ç–∞-—Ü–µ–Ω—Ç—Ä:</b> DC{report['dc_analysis']['current_dc']['dc_id'] if report['dc_analysis']['current_dc'] else '–ù–µ–≤—ñ–¥–æ–º–æ'}
üë§ <b>–ü–æ—Ç–æ—á–Ω–∏–π –Ω—ñ–∫–Ω–µ–π–º:</b> {report['username_analysis']['current_username'] or '–ù–µ–º–∞—î'}
üåê <b>–£–Ω—ñ–∫–∞–ª—å–Ω–∏—Ö IP:</b> {report['ip_analysis']['unique_ip_count']}

üîç <b>–ê–Ω–æ–º–∞–ª—ñ–π –≤–∏—è–≤–ª–µ–Ω–æ:</b> {len(report['username_analysis']['username_anomalies'])}
"""
        
        # –î–æ–¥–∞–≤–∞–Ω–Ω—è –∞–Ω–æ–º–∞–ª—ñ–π (—è–∫—â–æ —î)
        if report['username_analysis']['username_anomalies']:
            result_message += "\n‚ö†Ô∏è <b>–ê–Ω–æ–º–∞–ª—ñ—ó:</b>\n"
            for anomaly in report['username_analysis']['username_anomalies'][:5]:
                result_message += f"‚Ä¢ {anomaly}\n"
        
        # –î–æ–¥–∞–≤–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π
        if report['recommendations']:
            result_message += "\nüéØ <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó:</b>\n"
            for rec in report['recommendations'][:3]:
                result_message += f"‚Ä¢ {rec}\n"
        
        result_message += f"\nüî¢ <b>–¶–∏—Ñ—Ä–æ–≤–∏–π –≤—ñ–¥–±–∏—Ç–æ–∫:</b> <code>{report['summary']['metadata_fingerprint'][:32]}...</code>"
        
        # –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        await status_msg.edit_text(result_message, parse_mode="HTML")
        
        # –î–æ–¥–∞—Ç–∫–æ–≤—ñ –¥—ñ—ó –ø—Ä–∏ –≤–∏—Å–æ–∫–æ–º—É —Ä–∏–∑–∏–∫—É
        if report['summary']['threat_level'] in ["HIGH", "CRITICAL"]:
            await message.reply(
                f"üö® <b>–£–í–ê–ì–ê: –í–ò–°–û–ö–ò–ô –†–ò–ó–ò–ö</b>\n\n"
                f"–¶—ñ–ª—å {target} –º–∞—î —Ä—ñ–≤–µ–Ω—å –∑–∞–≥—Ä–æ–∑–∏ {report['summary']['threat_level']}. "
                f"–†–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –Ω–µ–≥–∞–π–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞.",
                parse_mode="HTML"
            )
    
    except Exception as e:
        await status_msg.edit_text(
            f"‚ùå <b>–ü–æ–º–∏–ª–∫–∞ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è:</b>\n<code>{str(e)}</code>",
            parse_mode="HTML"
        )

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∂–∏–≤–æ–≥–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
@dp.message(Command("monitor"))
async def start_monitoring(message: Message):
    """–ó–∞–ø—É—Å–∫ –∂–∏–≤–æ–≥–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É –º–µ—Ç–∞–¥–∞–Ω—ñ–≤"""
    
    args = message.text.split()
    if len(args) < 2:
        await message.reply("–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: /monitor <user_id>")
        return
    
    try:
        target_id = int(args[1])
        
        # –ó–∞–ø—É—Å–∫ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É –≤ –æ–∫—Ä–µ–º–æ–º—É –∑–∞–≤–¥–∞–Ω–Ω—ñ
        asyncio.create_task(
            xray_tracker.monitor_live_changes(target_id, "user")
        )
        
        await message.reply(
            f"‚úÖ <b>–ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω–æ</b>\n\n"
            f"–¶—ñ–ª—å: {target_id}\n"
            f"–Ü–Ω—Ç–µ—Ä–≤–∞–ª –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫: 5 —Ö–≤–∏–ª–∏–Ω\n"
            f"–ó–º—ñ–Ω–∏ –±—É–¥—É—Ç—å –ª–æ–≥—É–≤–∞—Ç–∏—Å—è –≤ —Å–∏—Å—Ç–µ–º—É –±–µ–∑–ø–µ–∫–∏.",
            parse_mode="HTML"
        )
        
    except ValueError:
        await message.reply("‚ùå –ù–µ–≤—ñ—Ä–Ω–∏–π ID. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —á–∏—Å–ª–æ–≤–∏–π ID")
```

üöÄ –Ü–ù–¢–ï–ì–†–ê–¶–Ü–Ø –í–°–Ü–• –ü–û–ö–†–ê–©–ï–ù–ò–• –§–£–ù–ö–¶–Ü–ô

–û–Ω–æ–≤–ª–µ–Ω–∏–π main.py –∑ —É—Å—ñ–º–∞ –º–æ–¥—É–ª—è–º–∏:

```python
# –î–æ–¥–∞—î–º–æ –¥–æ —ñ—Å–Ω—É—é—á–æ–≥–æ main.py

from core.forensic_snapshot import ForensicSnapshot
from core.ai_sentiment import AISentimentMonitor
from core.anti_ghost_recovery import AntiGhostRecovery
from core.xray_metadata import XRayMetadataTracker

class EnhancedShadowSystem:
    """–û—Å–Ω–æ–≤–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –∑ —É—Å—ñ–º–∞ –ø–æ–∫—Ä–∞—â–µ–Ω–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏"""
    
    def __init__(self, bot_token: str):
        self.bot_token = bot_token
        
        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–æ–∫—Ä–∞—â–µ–Ω–∏—Ö –º–æ–¥—É–ª—ñ–≤
        self.forensic = ForensicSnapshot()
        self.sentiment = AISentimentMonitor()
        self.ghost_recovery = AntiGhostRecovery(REDIS_URL)
        self.xray_tracker = XRayMetadataTracker()
        
        # –Ü–Ω—à—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ —Å–∏—Å—Ç–µ–º–∏
        self.security_monitor = SecurityMonitor()
        self.osint_engine = AdvancedOSINTEngine()
        self.ai_service = AIService()
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.start_time = datetime.now()
        self.processed_messages = 0
    
    async def initialize_enhanced_features(self):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—Å—ñ—Ö –ø–æ–∫—Ä–∞—â–µ–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π"""
        
        logger.info("üîÑ –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–æ–∫—Ä–∞—â–µ–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π...")
        
        try:
            # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–∏—Ö –∑–∞–¥–∞—á
            asyncio.create_task(self.forensic.monitor_self_destruct_timers())
            
            # –ó–∞–ø—É—Å–∫ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É –¥–ª—è –≤–∞–∂–ª–∏–≤–∏—Ö —á–∞—Ç—ñ–≤
            for chat_id in IMPORTANT_CHATS:
                asyncio.create_task(
                    self.sentiment.monitor_chat_sentiment(chat_id)
                )
                asyncio.create_task(
                    self.xray_tracker.monitor_live_changes(chat_id, "chat")
                )
            
            logger.info("‚úÖ –ü–æ–∫—Ä–∞—â–µ–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ")
            
        except Exception as e:
            logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –ø–æ–∫—Ä–∞—â–µ–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π: {e}")
    
    async def process_message_enhanced(self, message: Message):
        """
        –û–±—Ä–æ–±–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ —É—Å—ñ–º–∞ –ø–æ–∫—Ä–∞—â–µ–Ω–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏
        
        Args:
            message: –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è Telegram
        """
        
        self.processed_messages += 1
        
        # 1. –ê–Ω–∞–ª—ñ–∑ –Ω–∞—Å—Ç—Ä–æ—é
        sentiment_context = {
            'user_id': message.from_user.id,
            'chat_id': message.chat.id,
            'chat_type': message.chat.type,
            'is_important_chat': message.chat.id in IMPORTANT_CHATS
        }
        sentiment_analysis = await self.sentiment.analyze_text(
            message.text or message.caption or "",
            sentiment_context
        )
        
        # 2. –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
        message_data = {
            'message_id': message.message_id,
            'chat_id': message.chat.id,
            'user_id': message.from_user.id,
            'text': message.text or message.caption,
            'date': message.date
        }
        await self.ghost_recovery.capture_message(message_data)
        
        # 3. –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –º–µ–¥—ñ–∞ (—è–∫—â–æ —î)
        if (message.photo or message.video or message.document or 
            message.audio or message.voice or message.video_note):
            
            file_id = self._get_media_file_id(message)
            if file_id:
                # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç–∞ –æ–±—Ä–æ–±–∫–∞ –º–µ–¥—ñ–∞
                await self._process_media(message, file_id)
        
        # 4. X-Ray –∞–Ω–∞–ª—ñ–∑ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ (—è–∫—â–æ —Ü–µ –Ω–æ–≤–∏–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –∞–±–æ –ø—ñ–¥–æ–∑—Ä—ñ–ª–∏–π)
        if (sentiment_analysis.urgency_level > 5 or 
            sentiment_analysis.sentiment.value in ["PANIC", "COORDINATES"]):
            
            await self.xray_tracker.scan_target(
                message.from_user.id, 
                "user"
            )
        
        # 5. –õ–æ–≥—É–≤–∞–Ω–Ω—è –≤ —Å–∏—Å—Ç–µ–º—É –±–µ–∑–ø–µ–∫–∏
        await self.security_monitor.log_event(
            "MESSAGE_PROCESSED_ENHANCED",
            "INFO",
            "EnhancedShadowSystem",
            f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –æ–±—Ä–æ–±–ª–µ–Ω–æ –∑ –ø–æ–∫—Ä–∞—â–µ–Ω–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏",
            user_id=message.from_user.id,
            metadata={
                'chat_id': message.chat.id,
                'sentiment': sentiment_analysis.sentiment.value,
                'urgency': sentiment_analysis.urgency_level,
                'processed_count': self.processed_messages
            }
        )
    
    def _get_media_file_id(self, message: Message) -> Optional[str]:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è file_id –º–µ–¥—ñ–∞-–ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        if message.photo:
            return message.photo[-1].file_id
        elif message.video:
            return message.video.file_id
        elif message.document:
            return message.document.file_id
        elif message.audio:
            return message.audio.file_id
        elif message.voice:
            return message.voice.file_id
        elif message.video_note:
            return message.video_note.file_id
        return None
    
    async def _process_media(self, message: Message, file_id: str):
        """–û–±—Ä–æ–±–∫–∞ –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—É"""
        try:
            # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É
            file = await bot.get_file(file_id)
            file_data = await bot.download_file(file.file_path)
            
            # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ñ–æ—Ä–µ–Ω–∑–∏—á–Ω–æ–≥–æ –∑–Ω—ñ–º–∫—É
            file_info = {
                'file_id': file_id,
                'file_size': file.file_size,
                'file_path': file.file_path,
                'mime_type': getattr(message, 'mime_type', 'unknown')
            }
            
            context = {
                'user_id': message.from_user.id,
                'chat_id': message.chat.id,
                'message_id': message.message_id,
                'timestamp': message.date
            }
            
            await self.forensic.capture_media(file_data, file_info, context)
            
        except Exception as e:
            logger.error(f"Media processing error: {e}")
    
    async def get_system_status(self) -> Dict:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É –≤—Å—ñ—î—ó —Å–∏—Å—Ç–µ–º–∏"""
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑ —É—Å—ñ—Ö –º–æ–¥—É–ª—ñ–≤
        ghost_stats = await self.ghost_recovery.get_recovery_stats()
        xray_stats = self.xray_tracker.stats
        sentiment_stats = len(self.sentiment.analysis_history)
        
        # –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        total_stats = {
            'system_uptime': (datetime.now() - self.start_time).total_seconds(),
            'processed_messages': self.processed_messages,
            'ghost_recovery': ghost_stats,
            'xray_tracking': xray_stats,
            'sentiment_analyses': sentiment_stats,
            'forensic_snapshots': len(self.forensic.media_registry),
            'security_events': len(self.security_monitor.events)
        }
        
        return total_stats
```

üìä –î–ï–ú–û-–ü–ê–ù–ï–õ–¨ –î–õ–Ø –ê–î–ú–Ü–ù–Ü–°–¢–†–ê–¢–û–†–ê

```python
@dp.message(Command("enhanced_dashboard"))
async def enhanced_dashboard(message: Message):
    """–î–µ–º–æ-–ø–∞–Ω–µ–ª—å –∑ —É—Å—ñ–º–∞ –ø–æ–∫—Ä–∞—â–µ–Ω–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏"""
    
    # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—Ä–∞–≤ –∞–¥–º—ñ–Ω–∞
    if not await is_admin(message.from_user.id):
        await message.reply("‚õî –î–æ—Å—Ç—É–ø –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ")
        return
    
    # –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É —Å–∏—Å—Ç–µ–º–∏
    system = EnhancedShadowSystem(BOT_TOKEN)
    status = await system.get_system_status()
    
    # –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –ø–∞–Ω–µ–ª—ñ
    dashboard = f"""
üöÄ <b>SHADOW SYSTEM ENHANCED DASHBOARD v3.4</b>

‚è∞ <b>–ê–ø—Ç–∞–π–º:</b> {human_readable_time(status['system_uptime'], precise=True)}
üìä <b>–û–±—Ä–æ–±–ª–µ–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å:</b> {status['processed_messages']}

üîÆ <b>ANTI-GHOST RECOVERY</b>
‚îú‚îÄ –ó–∞—Ö–æ–ø–ª–µ–Ω–æ: {status['ghost_recovery']['total_captured']}
‚îú‚îÄ –í–∏–¥–∞–ª–µ–Ω–æ: {status['ghost_recovery']['total_deleted']}
‚îú‚îÄ –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ: {status['ghost_recovery']['total_recovered']}
‚îî‚îÄ –ï—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å: {status['ghost_recovery']['recovery_rate_percent']}%

üîç <b>X-RAY METADATA TRACKING</b>
‚îú‚îÄ –ü—Ä–æ—Ñ—ñ–ª—ñ–≤: {status['xray_tracking']['profiles_created']}
‚îú‚îÄ DC –∑–∞–ø–∏—Ç—ñ–≤: {status['xray_tracking']['dc_queries']}
‚îú‚îÄ –ü–µ—Ä–µ–≤—ñ—Ä–æ–∫ –Ω—ñ–∫–Ω–µ–π–º—ñ–≤: {status['xray_tracking']['username_checks']}
‚îî‚îÄ –ê–Ω–æ–º–∞–ª—ñ–π: {status['xray_tracking']['anomalies_detected']}

üß† <b>AI SENTIMENT MONITOR</b>
‚îú‚îÄ –ê–Ω–∞–ª—ñ–∑—ñ–≤: {status['sentiment_analyses']}
‚îú‚îÄ –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —á–∞—Ç—ñ–≤: {len(IMPORTANT_CHATS)}
‚îî‚îÄ –ê–∫—Ç–∏–≤–Ω—ñ –∞–ª–µ—Ä—Ç–∏: {len([a for a in system.sentiment.analysis_history if a.requires_attention])}

üì∏ <b>FORENSIC SNAPSHOT</b>
‚îú‚îÄ –ó–Ω—ñ–º–∫—ñ–≤: {status['forensic_snapshots']}
‚îú‚îÄ –†–æ–∑–º—ñ—Ä —Å—Ö–æ–≤–∏—â–∞: {format_bytes(sum(os.path.getsize(f) for f in Path('data/forensic_snapshots').rglob('*') if os.path.isfile(f)))}
‚îî‚îÄ –ê–≤—Ç–æ–≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è: –ê–∫—Ç–∏–≤–Ω–µ

üõ°Ô∏è <b>SECURITY MONITOR</b>
‚îî‚îÄ –ü–æ–¥—ñ–π: {status['security_events']}

‚ö° <b>–®–í–ò–î–ö–Ü –î–Ü–á:</b>
"""
    
    # –ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("üìä –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="enhanced_stats"),
        InlineKeyboardButton("üîç –°–∫–∞–Ω—É–≤–∞—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞", callback_data="enhanced_scan"),
        InlineKeyboardButton("üëª –í—ñ–¥–Ω–æ–≤–∏—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è", callback_data="enhanced_recover"),
        InlineKeyboardButton("üß† –ê–Ω–∞–ª—ñ–∑ —á–∞—Ç—É", callback_data="enhanced_analyze"),
        InlineKeyboardButton("üì∏ –§–æ—Ä–µ–Ω–∑–∏—á–Ω–∏–π –∑–≤—ñ—Ç", callback_data="enhanced_forensic"),
        InlineKeyboardButton("üîÑ –û–Ω–æ–≤–∏—Ç–∏", callback_data="enhanced_refresh")
    )
    
    await message.reply(dashboard, reply_markup=keyboard, parse_mode="HTML")
```

üéØ –ö–õ–Æ–ß–û–í–Ü –ü–ï–†–ï–í–ê–ì–ò –ü–û–ö–†–ê–©–ï–ù–û–á –°–ò–°–¢–ï–ú–ò:

1. Forensic Snapshot

¬∑ ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –¥–∑–µ—Ä–∫–∞–ª–∞ –º–µ–¥—ñ–∞-—Ñ–∞–π–ª—ñ–≤
¬∑ ‚úÖ –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏—Ö –º–µ—Ç–∞–¥–∞–Ω–∏—Ö (EXIF, –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—è, –¥–∞—Ç–∏)
¬∑ ‚úÖ –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ "—Ç–∞–π–º–µ—Ä—ñ–≤ —Å–∞–º–æ–∑–Ω–∏—â–µ–Ω–Ω—è"
¬∑ ‚úÖ –®–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è –∑–±–µ—Ä–µ–∂–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö
¬∑ ‚úÖ –ú–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –Ω–∞–≤—ñ—Ç—å –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∞–≤—Ç–æ—Ä–æ–º

2. AI Sentiment Monitor

¬∑ ‚úÖ –†–µ–∞–ª—å–Ω–∏–π —á–∞—Å –∞–Ω–∞–ª—ñ–∑—É –Ω–∞—Å—Ç—Ä–æ—é
¬∑ ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è –ø–∞–Ω—ñ–∫–∏, –∞–≥—Ä–µ—Å—ñ—ó, —Å—Ç—Ä–∞—Ö—É
¬∑ ‚úÖ –í–∏—è–≤–ª–µ–Ω–Ω—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ç–∞ –ø–ª–∞–Ω—É–≤–∞–Ω–Ω—è
¬∑ ‚úÖ –Ü–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω—ñ –∞–ª–µ—Ä—Ç–∏ –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö —Å–∏—Ç—É–∞—Ü—ñ—è—Ö
¬∑ ‚úÖ –Ü—Å—Ç–æ—Ä—ñ—è –∞–Ω–∞–ª—ñ–∑—É —Ç–∞ —Ç—Ä–µ–Ω–¥–∏

3. Anti-Ghost Recovery

¬∑ ‚úÖ 100% —Ç–æ—á–Ω—ñ—Å—Ç—å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
¬∑ ‚úÖ –Ü–Ω–¥–µ–∫—Å–∞—Ü—ñ—è –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–º'—è—Ç—ñ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ
¬∑ ‚úÖ –ë–∞–≥–∞—Ç–æ—Ä—ñ–≤–Ω–µ–≤–µ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è (RAM ‚Üí Redis ‚Üí Disk)
¬∑ ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω—å
¬∑ ‚úÖ –ú–∞—Å–æ–≤–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–ª—è —Ü—ñ–ª–∏—Ö —á–∞—Ç—ñ–≤

4. X-Ray Metadata Tracking

¬∑ ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –∑–∞–ø–∏—Ç DC ID —á–µ—Ä–µ–∑ osint_engine
¬∑ ‚úÖ –ü–æ–≤–Ω–∞ —ñ—Å—Ç–æ—Ä—ñ—è –∑–º—ñ–Ω–∏ –Ω—ñ–∫–Ω–µ–π–º—ñ–≤
¬∑ ‚úÖ –¢—Ä–µ–∫—ñ–Ω–≥ IP-–∞–¥—Ä–µ—Å —Ç–∞ –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—ó
¬∑ ‚úÖ –¶–∏—Ñ—Ä–æ–≤—ñ –≤—ñ–¥–±–∏—Ç–∫–∏ –ø—Ä–æ—Ñ—ñ–ª—ñ–≤
¬∑ ‚úÖ –ñ–∏–≤–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –∑–º—ñ–Ω –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
¬∑ ‚úÖ –û—Ü—ñ–Ω–∫–∞ —Ä—ñ–≤–Ω—è –∑–∞–≥—Ä–æ–∑–∏
